<!DOCTYPE html>
<html>
<head>
  <title>COSC 4820 Database Systems</title>
  <meta charset="utf-8">
  <meta name="description" content="COSC 4820 Database Systems">
  <meta name="author" content="Ruben Gamboa">
  <meta name="generator" content="slidify" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/default.css" media="all" >
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/phone.css" 
    media="only screen and (max-device-width: 480px)" >
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/slidify.css" >
  <link rel="stylesheet" href="libraries/highlighters/highlight.js/css/tomorrow.css" />
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->  <link rel=stylesheet href="libraries/widgets/bootstrap/css/bootstrap.css"></link>
<link rel=stylesheet href="./assets/css/ribbons.css"></link>

  
  <!-- Grab CDN jQuery, fall back to local if offline -->
  <script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.7.min.js"></script>
  <script>window.jQuery || document.write('<script src="libraries/widgets/quiz/js/jquery.js"><\/script>')</script> 
  <script data-main="libraries/frameworks/io2012/js/slides" 
    src="libraries/frameworks/io2012/js/require-1.0.8.min.js">
  </script>
  
  

</head>
<body style="opacity: 0">
  <slides class="layout-widescreen">
    
    <!-- LOGO SLIDE -->
        <slide class="title-slide segue nobackground">
  <hgroup class="auto-fadein">
    <h1>COSC 4820 Database Systems</h1>
    <h2>Views and Indexes</h2>
    <p>Ruben Gamboa<br/>Professor</p>
  </hgroup>
  <article></article>  
</slide>
    

    <!-- SLIDES -->
    <slide class="" id="slide-1" style="background:;">
  <article data-timings="">
    <style>
.title-slide {
     background-color: #EDE0CF; /* CBE7A5; #EDE0CF; ; #CA9F9D*/
     background-image: url(assets/img/uw-logo-large.png);
     background-repeat: no-repeat;
     background-position: center top;
   }
</style>

<h2>Chapter Overview</h2>

<ul>
<li>First, we&#39;ll address the last <strong>active element</strong></li>
<li>A <strong>view</strong> is a SQL query that is stored in the database</li>
<li>It appears to be a table</li>
<li>But it&#39;s actually a query that is executed as needed
<br><br></li>
<li>Then we&#39;ll discuss a very important topic for relational databases</li>
<li>An <strong>index</strong> is a specialized data structure</li>
<li>Its only purpose is to <strong>speed up</strong> certain queries</li>
<li>Without indexes, relational databases would be totally impractical</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-2" style="background:;">
  <hgroup>
    <h1>Virtual Views</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-3" style="background:;">
  <hgroup>
    <h2>Virtual Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>A <strong>virtual view</strong> is just a query that is stored in the database</li>
<li>It can be queried just as any other table</li>
<li>But it may be a read-only table (i.e., no inserts, updates, deletes)
<br><br></li>
<li>Views are created with the <code>CREATE VIEW ... AS ...</code> command</li>
</ul>

<pre><code>CREATE VIEW GoodMovies AS
  SELECT title, year, length, genre
    FROM Movies JOIN StarsIn ON title = movieTitle AND year = movieYear
   WHERE StarsIn.name = &#39;Harrison Ford&#39;
     AND Movies.studioName = &#39;Lucasfilm&#39;
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-4" style="background:;">
  <hgroup>
    <h2>Querying Virtual Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>There is actually no magic here</li>
<li>As far as querying is concerned, a view is the same as a table</li>
</ul>

<pre><code>SELECT title, year
  FROM GoodMovies
 WHERE year &lt; 2000
</code></pre>

<ul>
<li>This query shows only the movies made by Lucasfilm and starring Harrison Ford</li>
<li>But the only reason we know that is because we know the <strong>definition</strong> of the view</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-5" style="background:;">
  <hgroup>
    <h2>Querying Virtual Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>In fact, you can think of the view as being replaced by its definition</li>
</ul>

<pre><code>SELECT title, year
  FROM (SELECT title, year, length, genre
          FROM Movies JOIN StarsIn ON title = movieTitle AND year = movieYear
         WHERE StarsIn.name = &#39;Harrison Ford&#39;
           AND Movies.studioName = &#39;Lucasfilm&#39;)
       AS GoodMovies
 WHERE year &lt; 2000
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-6" style="background:;">
  <hgroup>
    <h2>Virtual Views to Simplify Queries</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>One use of Virtual Views is to create &quot;tables&quot; that would otherwise violate normal forms</li>
<li>E.g., suppose relation \(R\) is decomposed into \(R_1\) and \(R_2\)</li>
<li>Then we can use a view to <strong>recreate</strong> the original relation \(R\)</li>
<li>This may make it easier for people to query the database</li>
</ul>

<pre><code>CREATE VIEW MovieInfo AS
  SELECT Movies.title, Movies.year, Movies.length, Movies.genre,
         Studios.name AS studioName, Studios.address AS studioAddress,
         Stars.name AS starName, Stars.address AS starAddress
    FROM Movies JOIN StarsIn ON title = movieTitle AND year = movieYear
                JOIN Stars   ON starName = Stars.name
                JOIN Studios ON studioName = Studios.name
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-7" style="background:;">
  <hgroup>
    <h2>Renaming Attributes</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Notice that we used AS in the SELECT query to rename the attributes</li>
<li>This gives good attribute names to the view</li>
<li>An alternative is to explicitly provide the names to the table</li>
<li>This has the advantage of making the view&#39;s schema more transparent</li>
</ul>

<pre><code>CREATE VIEW MovieInfo (title, year, length, genre,
                       studioName, studioAddress,
                       starName, starAddress) AS
  SELECT Movies.title, Movies.year, Movies.length, Movies.genre,
         Studios.name, Studios.address,
         Stars.name, Stars.address
    FROM Movies JOIN StarsIn ON title = movieTitle AND year = movieYear
                JOIN Stars   ON starName = Stars.name
                JOIN Studios ON studioName = Studios.name
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-8" style="background:;">
  <hgroup>
    <h2>Virtual Views to Secure Data</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Another use of Virtual Views is to create &quot;tables&quot; that hide information
that some user is not entitled to</li>
<li>E.g., the MovieStars table shows a star&#39;s <strong>address</strong> and <strong>birthdate</strong></li>
<li>Perhaps these two fields should be kept private</li>
</ul>

<pre><code>CREATE VIEW StarInfo AS
  SELECT name, gender
    FROM MovieStars
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-9" style="background:;">
  <hgroup>
    <h1>Updating Views</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-10" style="background:;">
  <hgroup>
    <h2>Updating Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Updates on views may or may not make sense</li>
<li>E.g., consider this view:</li>
</ul>

<pre><code>CREATE VIEW StudentCourseCount(studentId, courseCount) AS
  SELECT Students.id, COUNT(*)
    FROM Students JOIN EnrolledIn ON Students.id = EnrolledIn.StudentId
   GROUP BY Students.id
</code></pre>

<ul>
<li>How are we supposed to interpret this update statement?</li>
</ul>

<pre><code>UPDATE StudentCourseCount
   SET courseCount = courseCount + 1
 WHERE studentId = 42
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-11" style="background:;">
  <hgroup>
    <h2>Updating Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>On the other hand, there&#39;s a perfectly good expectation for this query</li>
</ul>

<pre><code>UPDATE StudentCourseCount
   SET courseCount = 0
 WHERE studentId = 42
</code></pre>

<ul>
<li>The same goes for</li>
</ul>

<pre><code>DELETE FROM StudentCourseCount
 WHERE studentId = 42
</code></pre>

<ul>
<li>But that&#39;s too much to expect from a database!</li>
<li>Instead, we want to find cases where the meaning is clear, both to a programmer and the database system</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-12" style="background:;">
  <hgroup>
    <h2>Removing Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We start with an easy case</li>
</ul>

<pre><code>DROP VIEW StudentCourseCount
</code></pre>

<ul>
<li>This removes the view from the database</li>
<li>But it <strong>does not</strong> remove the underlying tables</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-13" style="background:;">
  <hgroup>
    <h2>Removing Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Even this case is subtle</li>
</ul>

<pre><code>DROP TABLE EnrolledIn
</code></pre>

<ul>
<li>What happened to the view?</li>
<li>Sadly, <strong>nothing</strong></li>
<li>The view is still there, and we can still query it</li>
<li>But when we query it, we will get a run-time error</li>
<li>There is no &quot;referential integrity&quot; for views!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-14" style="background:;">
  <hgroup>
    <h2>Updating Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We&#39;ve seen that not all views can be updated</li>
<li>What about the following view</li>
</ul>

<pre><code>CREATE VIEW ScifiMovies(title, year, length) AS
  SELECT title, year, length
    FROM Movies
   WHERE genre = &#39;scifi&#39;
</code></pre>

<ul>
<li>Now, suppose we did the following</li>
</ul>

<pre><code>UPDATE ScifiMovies
   SET length = 120
 WHERE title = &#39;Blade Runner&#39;
   AND year = 1982
</code></pre>

<ul>
<li>That should work, right?</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-15" style="background:;">
  <hgroup>
    <h2>Updating Views</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>CREATE VIEW ScifiMovies(title, year, length) AS
  SELECT title, year, length
    FROM Movies
   WHERE genre = &#39;scifi&#39;
</code></pre>

<ul>
<li>And what if we did this</li>
</ul>

<pre><code>INSERT INTO ScifiMovies(title, year, length)
     VALUES (&#39;Blade Runner&#39;, 1982, 120)
</code></pre>

<ul>
<li>That should work, too, right?</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-16" style="background:;">
  <hgroup>
    <h2>Updating Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>And what if we changed the definition of the view to this</li>
</ul>

<pre><code>CREATE VIEW ScifiMovies(title, year, length) AS
  SELECT title, year, length
    FROM Movies
   WHERE TO_LOWER(genre) = &#39;scifi&#39;
</code></pre>

<ul>
<li>Should the updates still work?
<br><br></li>
<li>Maybe we&#39;re asking too much from the database!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-17" style="background:;">
  <hgroup>
    <h2>Updatable Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We can remove all ambiguity by deciding on which types of views are updatable</li>
<li>That is, without asking databases to be full-fledged AIs!</li>
</ul>

<ol class = "build incremental">
<li>The FROM clause must have only one relation \(R\) and only one occurrence of the relation \(R\)</li>
<li>The relation \(R\) may be a table or another updatable view</li>
<li>The WHERE clause must not involve \(R\) in a subquery (though it may have subqueries referencing other relations)</li>
<li>The SELECT clause must involve only simple attributes from \(R\)</li>
<li>Any attribute that is left out of the SELECT must allow NULL values or have a declared DEFAULT value</li>
<li>The SELECT clause must not be SELECT DISTINCT</li>
</ol>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-18" style="background:;">
  <hgroup>
    <h2>Updating Updatable Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Updating (inserting, deleting) an updatable view simply propagates the update (insertion, deletion) to the
underlying table</li>
<li>E.g., UPDATE \(R\) ... instead of UPDATE \(V_R\) ...</li>
<li>If the command has a WHERE clause, the condition of the view is automatically added
<br><br></li>
<li>The definition of &quot;updatable view&quot; is meant to make this process straightforward</li>
<li>There are a number of surprises waiting for us, though!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-19" style="background:;">
  <hgroup>
    <h2>Inserting into an Updatable View</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Consider again this view</li>
</ul>

<pre><code>CREATE VIEW ScifiMovies(title, year, length) AS
  SELECT title, year, length
    FROM Movies
   WHERE genre = &#39;scifi&#39;
</code></pre>

<ul>
<li>This meets all the requirements for updatable views!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-20" style="background:;">
  <hgroup>
    <h2>Inserting into an Updatable View</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>CREATE VIEW ScifiMovies(title, year, length) AS
  SELECT title, year, length
    FROM Movies
   WHERE genre = &#39;scifi&#39;
</code></pre>

<ul>
<li>Consider this insertion</li>
</ul>

<pre><code>INSERT INTO ScifiMovies(title, year, length)
     VALUES (&#39;Blade Runner&#39;, 1982, 120)
</code></pre>

<ul>
<li>Following our rules, this translates into</li>
</ul>

<pre><code>INSERT INTO Movies(title, year, length)
     VALUES (&#39;Blade Runner&#39;, 1982, 120)
</code></pre>

<ul>
<li>That works, but the genre of the new row is NULL!</li>
<li>This is extra embarrassing, since it means the new tuple <strong>will not show up on the view</strong></li>
</ul>

<pre><code>SELECT * FROM ScifiMovies
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-21" style="background:;">
  <hgroup>
    <h2>Deleting from an Updatable View</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>CREATE VIEW ScifiMovies(title, year, length) AS
  SELECT title, year, length
    FROM Movies
   WHERE genre = &#39;scifi&#39;
</code></pre>

<ul>
<li>Consider this deletion</li>
</ul>

<pre><code>DELETE FROM ScifiMovies
      WHERE title = &#39;Blade Runner&#39;
</code></pre>

<ul>
<li>Suppose we translated this as</li>
</ul>

<pre><code>DELETE FROM Movies
      WHERE title = &#39;Blade Runner&#39;
</code></pre>

<ul>
<li>This would delete the rows we want, and also some innocent rows in the original table!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-22" style="background:;">
  <hgroup>
    <h2>Deleting from an Updatable View</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>CREATE VIEW ScifiMovies(title, year, length) AS
  SELECT title, year, length
    FROM Movies
   WHERE genre = &#39;scifi&#39;
</code></pre>

<ul>
<li>Consider this deletion</li>
</ul>

<pre><code>DELETE FROM ScifiMovies
      WHERE title = &#39;Blade Runner&#39;
</code></pre>

<ul>
<li>To avoid problems, this is actually treated as</li>
</ul>

<pre><code>DELETE FROM Movies
      WHERE (title = &#39;Blade Runner&#39;)
        AND (genre = &#39;scifi&#39;)
</code></pre>

<ul>
<li>The parentheses are there to show us that the query could be arbitrarily complex</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-23" style="background:;">
  <hgroup>
    <h2>Updating an Updatable View</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>CREATE VIEW ScifiMovies(title, year, length) AS
  SELECT title, year, length
    FROM Movies
   WHERE genre = &#39;scifi&#39;
</code></pre>

<ul>
<li>Consider this update</li>
</ul>

<pre><code>UPDATE ScifiMovies
   SET length = 120
 WHERE title = &#39;Blade Runner&#39; AND year = 1982
</code></pre>

<ul>
<li>Following our rules, this is translated into</li>
</ul>

<pre><code>UPDATE Movies
   SET length = 120
 WHERE (title = &#39;Blade Runner&#39; AND year = 1982)
   AND (genre = &#39;scifi&#39;)
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-24" style="background:;">
  <hgroup>
    <h2>Updatable Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We&#39;ve seen how we can update some views</li>
<li>DELETE and UPDATE worked well, but INSERT was problematic at best
<br><br></li>
<li>SQL provides an awkward solution</li>
<li>What&#39;s needed is a way to say

<ul>
<li>When you INSERT a row into ScifiMovies, be sure to set the genre to &#39;scifi&#39;
<br><br></li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>Hey, that sounds like a trigger!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-25" style="background:;">
  <hgroup>
    <h2>INSTEAD OF Triggers</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>SQL provides INSTEAD OF triggers to take carte of this scenario</li>
<li>These are in the same category as BEFORE or AFTER triggers</li>
</ul>

<pre><code>CREATE TRIGGER ScifiMoviesInsert
INSTEAD OF INSERT ON ScifiMovies
REFERENCING 
    NEW ROW AS NewRow
FOR EACH ROW
    INSERT INTO Movies(title, year, length, genre)
         VALUES (NewRow.title, NewRow.year, NewRow.length, &#39;scifi&#39;)
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-26" style="background:;">
  <hgroup>
    <h2>Aside: Aspect-Oriented Programming</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Aspect-Oriented Programming (AOP) is a flavor of OOP that includes the notions of

<ul>
<li>cross-cutting concerns</li>
<li>advice
<br><br></li>
</ul></li>
<li>It is supported directly in some languages (e.g., AspectJ)</li>
<li>It is also supported by some frameworks (e.g., Spring for Java)
<br><br></li>
<li>There are three kinds of <strong>advice</strong>:

<ol>
<li>Before advice</li>
<li>After advice</li>
<li>Instead of advice</li>
</ol></li>
<li>Hmmm....</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-27" style="background:;">
  <hgroup>
    <h1>Materialized Views</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-28" style="background:;">
  <hgroup>
    <h2>Materialized Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>So far, we&#39;ve considered the <strong>nested query</strong> interpretation of views</li>
<li>This is the default, and it works remarkably well for the purposes we&#39;ve seen so far
<br><br></li>
<li>But there&#39;s another reason why views may be useful</li>
<li>If we can precompute the view, we may be able to use it to make queries faster
<br><br></li>
<li>So we may be able to improve performance by saving the results of views to disk</li>
<li>Then we really are treating them the same as tables</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-29" style="background:;">
  <hgroup>
    <h2>Materialized Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>For example, suppose we often issue queries where we need the president of a studio</li>
<li>We can do this with the following view</li>
</ul>

<pre><code>CREATE MATERIALIZED VIEW MovieProd AS
    SELECT title, year, length, genre, name AS producerName
      FROM Movies JOIN MovieExec on producerC# = cert#
</code></pre>

<ul>
<li>Now, we can get movies and producers without needing to execute a join</li>
</ul>

<pre><code>SELECT title, year, producerName
  FROM MovieProd
 WHERE year &gt;= 2010
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-30" style="background:;">
  <hgroup>
    <h2>Materialized Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We believe that executing a query on a view is faster than performing the defining join</li>
<li>Suppose we find a query such as</li>
</ul>

<pre><code>SELECT year, name
  FROM Movies JOIN MovieExec on producerC# = cert#
 ORDER BY year
</code></pre>

<ul>
<li>We should replace this query with</li>
</ul>

<pre><code>SELECT year, producerName as name
  FROM MovieProd
 GROUP BY year
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-31" style="background:;">
  <hgroup>
    <h2>Materialized Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Consider this query</li>
</ul>

<pre><code>SELECT name, COUNT(*)
  FROM Movies JOIN MovieExec on producerC# = cert#
 GROUP BY cert#
</code></pre>

<ul>
<li>We may want to replace it with</li>
</ul>

<pre><code>SELECT producerName as name, COUNT(*)
  FROM MovieProd
 GROUP BY producerName
</code></pre>

<ul>
<li>The problem is that this <strong>does not work</strong>, because we are grouping by name instead of cert#</li>
<li>There could be two producers with the same name!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-32" style="background:;">
  <hgroup>
    <h2>Materialized Views</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>To take advantage of materialized views, we must replace tables and conditions with the equivalent materialized views</li>
<li>But we must be very careful that we are being faithful to the original query!
<br><br></li>
<li>In some databases, the optimizer can use materialized views automatically</li>
<li>But this is not something you should depend on!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-33" style="background:;">
  <hgroup>
    <h2>Maintaining Materialized Views in Sync</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>CREATE MATERIALIZED VIEW MovieProd AS
    SELECT title, year, length, genre, name AS producerName
      FROM Movies JOIN MovieExecs on producerC# = cert#
</code></pre>

<ul>
<li>First, let&#39;s observe that MovieProd is <strong>not</strong> an updatable view</li>
<li>The real question is, how do we maintain the rows in MovieProd when
Movies or MovieExecs change?
<br><br></li>
<li>This is an example of the more general <strong>cache coherency</strong> problem</li>
<li>We have three possible solutions

<ol>
<li>Recompute the view every time there&#39;s a change</li>
<li>Try to figure out how to change the view <strong>incrementally</strong></li>
<li>Recompute the view every night</li>
</ol></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-34" style="background:;">
  <hgroup>
    <h2>Maintaining Materialized Views in Sync</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Obviously, these solutions can be very expensive!

<ol>
<li>Recompute the view every time there&#39;s a change</li>
<li>Try to figure out how to change the view <strong>incrementally</strong></li>
<li>Recompute the view every night
<br><br></li>
</ol></li>
<li>This only makes sense when

<ul>
<li>there are very few (or no) updates to the data</li>
<li>the materialized view does not need to be very current</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-35" style="background:;">
  <hgroup>
    <h2>Incremental Insertions</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>CREATE MATERIALIZED VIEW MovieProd AS
    SELECT title, year, length, genre, name AS producerName
      FROM Movies JOIN MovieExecs on producerC# = cert#
</code></pre>

<ul>
<li>Suppose we insert a new tuple into Movies</li>
</ul>

<pre><code>INSERT INTO Movies(title, year, cert#) VALUES (&#39;Kill Bill&#39;, 2003, 23456)
</code></pre>

<ul>
<li>We can keep MovieProd in sync by adding the corresponding tuple for &#39;Kill Bill&#39;</li>
<li>All we need to do is find the producerName, and we can get that by querying the MovieExecs table</li>
</ul>

<pre><code>INSERT INTO MovieProd(title, year, producerName) 
    SELECT &#39;Kill Bill&#39;, 2003, name
      FROM MovieExecs 
     WHERE cert#=23456
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-36" style="background:;">
  <hgroup>
    <h2>Incremental Insertions</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>CREATE MATERIALIZED VIEW MovieProd AS
    SELECT title, year, length, genre, name AS producerName
      FROM Movies JOIN MovieExecs on producerC# = cert#
</code></pre>

<ul>
<li>Suppose we insert a new tuple into MovieExecs</li>
</ul>

<pre><code>INSERT INTO MovieExecs(cert#, name) VALUES (23456, &#39;Quentin Tarantino&#39;)
</code></pre>

<ul>
<li>We can keep MovieProd in sync by adding the corresponding tuple for cert# 23456</li>
<li>All we need to do is find the movies produced by this cert#</li>
</ul>

<pre><code>INSERT INTO MovieProd(title, year, producerName) 
    SELECT title, year, &#39;Quentin Tarantino&#39;
      FROM Movies
     WHERE producerC# = 23456
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-37" style="background:;">
  <hgroup>
    <h2>Incremental Deletions</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>CREATE MATERIALIZED VIEW MovieProd AS
    SELECT title, year, length, genre, name AS producerName
      FROM Movies JOIN MovieExecs on producerC# = cert#
</code></pre>

<ul>
<li>Suppose we delete a tuple from Movies</li>
</ul>

<pre><code>DELETE FROM Movies WHERE title=&#39;Kill Bill&#39; AND year=2003
</code></pre>

<ul>
<li>We can keep MovieProd in sync by deleting the corresponding tuples</li>
</ul>

<pre><code>DELETE FROM MovieProd
 WHERE (title, year) IN (SELECT title, year
                           FROM Movies
                          WHERE title=&#39;Kill Bill&#39; AND year=2003)
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-38" style="background:;">
  <hgroup>
    <h2>Incremental Deletions</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>CREATE MATERIALIZED VIEW MovieProd AS
    SELECT title, year, length, genre, name AS producerName
      FROM Movies JOIN MovieExecs on producerC# = cert#
</code></pre>

<ul>
<li>Suppose we delete a tuple from MovieExecs</li>
</ul>

<pre><code>DELETE FROM MovieExecs WHERE cert#=23456
</code></pre>

<ul>
<li>We can keep MovieProd in sync by deleting the corresponding tuples</li>
</ul>

<pre><code>DELETE FROM MovieProd
 WHERE producerName IN (SELECT name
                          FROM MovieExecs
                         WHERE cert#=23456)
</code></pre>

<ul class = "build incremental">
<li>Wait! That doesn&#39;t work!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-39" style="background:;">
  <hgroup>
    <h2>Incremental Deletions</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>CREATE MATERIALIZED VIEW MovieProd AS
    SELECT title, year, length, genre, name AS producerName
      FROM Movies JOIN MovieExecs on producerC# = cert#
</code></pre>

<ul>
<li>Suppose we delete a tuple from MovieExecs</li>
</ul>

<pre><code>DELETE FROM MovieExecs WHERE cert#=23456
</code></pre>

<ul>
<li>We can&#39;t just delete entries with the given producerName</li>
<li>That fails because there could be more than one producer with the name</li>
<li>Here&#39;s an approach that always works (but be careful with timeline of execution)</li>
</ul>

<pre><code>DELETE FROM MovieProd
 WHERE (title, year, producerName) IN (SELECT title, year, name
                                         FROM Movies JOIN MovieExecs on producerC# = cert#
                                        WHERE cert#=23456)
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-40" style="background:;">
  <hgroup>
    <h2>Incremental Updates</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>CREATE MATERIALIZED VIEW MovieProd AS
    SELECT title, year, length, genre, name AS producerName
      FROM Movies JOIN MovieExecs on producerC# = cert#
</code></pre>

<ul>
<li>The same approach works for updates</li>
</ul>

<pre><code>UPDATE MovieExecs SET name=&#39;Quentin Tarantino&#39; WHERE cert#=23456
</code></pre>

<ul>
<li>This can be translated into</li>
</ul>

<pre><code>UPDATE MovieProd
   SET name=&#39;Quentin Tarantino&#39;
 WHERE (title, year, producerName) IN (SELECT title, year, name
                                         FROM Movies JOIN MovieExecs on producerC# = cert#
                                        WHERE cert#=23456)
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-41" style="background:;">
  <hgroup>
    <h1>Indexes in SQL</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-42" style="background:;">
  <hgroup>
    <h2>Indexes in SQL</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>An <strong>index</strong> is a <strong>data structure</strong> that makes it more efficient to retrieve tuples that have a given value 
for a given attribute
<br><br></li>
<li>For example, an index on the <strong>Student ID</strong> attribute would make it efficient to find a student with W# &quot;W123456789&quot;</li>
<li>Or an index on <strong>phone number</strong> would make it efficient to find a student or students with phone number &quot;307-234-5678&quot;</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-43" style="background:;">
  <hgroup>
    <h2>Indexes in SQL</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>In memory, you would solve this problem by using a data structure such as

<ol>
<li>a sorted array</li>
<li>a (binary) search tree</li>
<li>a hash table
<br><br></li>
</ol></li>
</ul>

<ul class = "build incremental">
<li><p>Actually, all of these are used in databases</p>

<ol>
<li>A sorted file</li>
<li>A B-tree with as many children as fit in a disk page</li>
<li>A hash table, with &quot;buckets&quot; mapping to different disk pages
<br><br></li>
</ol></li>
<li><p>Note: Sorted files and B-trees can handle comparisons with &lt;, &lt;=, &gt;, &gt;=, and =</p></li>
<li><p>But hash tables can only handle equality checks</p></li>
<li><p>And (rule of thumb) they are more efficient than the others</p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-44" style="background:;">
  <hgroup>
    <h2>Motivation for indexes</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we need to compute \(S \bowtie S\), where \(S\) is the Students table at UW</li>
<li>Since \(|S| \approx 13000\), the naive method takes up \(13000^2 =\) 1.69 &times; 10<sup>8</sup> steps</li>
<li>Each step is a disk access, so even if disk I/O is 1ms, that works out to 1.69 &times; 10<sup>5</sup> seconds</li>
<li>Which is 2816.6666667 minutes</li>
<li>Which is 46.9444444 hours</li>
<li>Which is 1.9560185 days
<br><br></li>
</ul>

<ul class = "build incremental">
<li>That&#39;s a little unfair</li>
<li><p>Instead of reading each tuple at a time, we can read many tuples at the same time, since they are 
on the same disk page</p></li>
<li><p>Disk I/Os is what matters, so we&#39;ll stop worrying about seconds</p></li>
<li><p>After all, disks get faster!</p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-45" style="background:;">
  <hgroup>
    <h2>Motivation for indexes</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we need to compute \(S \bowtie S\), where \(S\) is the Students table at UW</li>
<li>Suppose each disk page can handle 100 students</li>
<li><p>Since \(|S| \approx 13000\) or 130 pages, the <strong>Block Nested Loop</strong> join method takes up \(130+130^2 =\) 1.703 &times; 10<sup>4</sup> disk I/Os
<br><br></p></li>
<li><p>That&#39;s a lot better, but it&#39;s still quadratic!</p></li>
<li><p>A good index will bring that <strong>up</strong> to 3.263 &times; 10<sup>4</sup> disk I/Os</p></li>
<li><p>But it&#39;s <strong>linear</strong></p></li>
<li><p>You&#39;d see an improvement in a larger school</p></li>
<li><p>E.g., with 100,000 students, it becomes</p>

<ul>
<li>Without an index: \(1000^2 =\) 10<sup>6</sup> disk I/Os</li>
<li>With an index: 2.51 &times; 10<sup>5</sup> disk I/Os</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-46" style="background:;">
  <hgroup>
    <h2>Motivation for indexes</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The &quot;hard&quot; numbers in the previous slides involve joins</li>
<li><p>Here&#39;s a similar argument with selections</p></li>
<li><p>Suppose we need to compute \(\sigma(S)\), where \(S\) is the Students table at UW</p></li>
<li><p>Suppose each disk page can handle 100 students</p></li>
<li><p>Since \(|S| \approx 13000\) or 130 pages, without an index, we can execute the selection with \(130\) disk I/Os</p></li>
</ul>

<p><br></p>

<ul>
<li>A good (and applicable) index will bring that down to 2.5 disk I/Os!</li>
<li>Actually, it could be a few more, depending on the <strong>selectivity</strong> of the index (more on this later)

<ul>
<li>If we&#39;re looking for a single record, then 2.5 disk I/Os is about right</li>
<li>If we&#39;re looking for all students in COSC, it may take \(200\) disk I/Os!</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-47" style="background:;">
  <hgroup>
    <h2>Motivation for indexes</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Indexes can be used to speed up queries that involve selections, e.g.,</li>
</ul>

<pre><code>SELECT title, year
  FROM Movies
 WHERE year = 2000
</code></pre>

<ul>
<li>They can also be used to speed up queries involving joins</li>
</ul>

<pre><code>SELECT title, year, name
  FROM Movies JOIN MovieExecs ON producerC# = cert#
 WHERE year = 2000
</code></pre>

<ul>
<li>And indexes can speed up checking of integrity constraints, e.g., W# must be unique</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-48" style="background:;">
  <hgroup>
    <h2>Declaring Indexes</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Making an index is as easy as calling <code>CREATE INDEX</code></li>
</ul>

<pre><code>CREATE INDEX MovieYearIdx ON Movies(year)
</code></pre>

<ul>
<li>You would not have to make an index on cert#, because databases automatically create an index on the PRIMARY KEY</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-49" style="background:;">
  <hgroup>
    <h2>Multidimensional Indexes</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>You can create an index that spans more than one attribute</li>
</ul>

<pre><code>CREATE INDEX StudentNameIdx ON Students(first_name, last_name)
</code></pre>

<ul>
<li>The order of the attributes matters!</li>
<li>If you know the first_name, but not the last_name, you may still be ab;e to use the index above effectively</li>
<li>But if you know the last_name and not the first_name, this index is useless
<br><br></li>
</ul>

<ul class = "build incremental">
<li>Note that if the index is a hash index, then knowing one or the other does not help!</li>
<li>This only helps for indexes that have a sort order, e.g., sorted files or tree indexes</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-50" style="background:;">
  <hgroup>
    <h2>Dropping Indexes</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>No surprises here:</li>
</ul>

<pre><code>DROP INDEX MovieYearIdx
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-51" style="background:;">
  <hgroup>
    <h1>What Indexes to Pick?</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-52" style="background:;">
  <hgroup>
    <h2>What Indexes to Pick?</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The choices you make when picking indexes will likely determine whether the database performance is acceptable or not
<br><br></li>
<li>One approach is to create all possible indexes! (Why not?)

<ul>
<li>If you have a table with 10 attributes, that&#39;s 1023 indexes</li>
<li>If you have a table with 20 attributes, that&#39;s 1.048575 &times; 10<sup>6</sup> indexes
<br><br></li>
</ul></li>
<li>OK, that may be too much</li>
<li>How about an index on each column?</li>
<li>10 attributes means 10 indexes, 20 attributes means 20 indexes
<br><br></li>
<li>This is manageable, but consider that each update to the database needs to update each of the indexes!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-53" style="background:;">
  <hgroup>
    <h2>Basic Tradeoffs</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Indexes may speed up queries with selections and joins
<br><br></li>
<li>Indexes may slow down insertions, deletions, and updates</li>
</ul>

<p><br></p>

<ul class = "build incremental">
<li>These are just guidelines!</li>
<li>An index may slow down a query, e.g, adding an index on &quot;gender&quot; may confuse the optimizer</li>
<li>An index may speed up an insertion, e.g., by making a constraint check faster</li>
</ul>

<p><br></p>

<ul class = "build incremental">
<li>We&#39;ll now discuss some indexes that are usually good ideas</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-54" style="background:;">
  <hgroup>
    <h2>Primary Key Indexes</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>It is usually a good idea to have an index on a primary key

<ul>
<li>Queries typically join on primary keys, so the index will be used a lot</li>
<li>The index returns at most one tuple, so at most one page will need to be read
<br></li>
</ul></li>
<li>Suppose we need to compute \(S \bowtie S\), where \(S\) is the Students table at UW</li>
<li>Suppose each disk page can handle 100 students</li>
<li>Since \(|S| \approx 13000\) or 130 pages, the <strong>Index Nested Loop</strong> join method takes up

<ul>
<li>\(130\) disk I/Os to read the entire table</li>
<li>for each tuple, at most one more disk I/O to find the matching tuple</li>
</ul></li>
<li>The grand total is \(130 + 13000 \times 1 =\) 1.313 &times; 10<sup>4</sup> disk I/Os</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-55" style="background:;">
  <hgroup>
    <h2>Primary Key Indexes</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Actually, the analysis is slightly wrong</li>
<li>We counted the disk I/Os to read the tuples, but <strong>we never counted the disk I/Os for the index itself</strong></li>
</ul>

<p><br></p>

<ul>
<li>Rule of thumb: Each lookup on a tree-based index costs 3 disk I/Os (but it would be probably be just 2 on 13,000 rows)</li>
<li>Rule of thumb: Each lookup on a hash-based index costs 1.5 disk I/Os</li>
</ul>

<p><br></p>

<ul>
<li>Using these rough estimates, we find

<ul>
<li>Using a tree index: \(130 + 13000 \times (1 + 3) =\) 5.213 &times; 10<sup>4</sup> disk I/Os</li>
<li>Using a hash index: \(130 + 13000 \times (1 + 1.5) =\) 3.263 &times; 10<sup>4</sup> disk I/Os</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-56" style="background:;">
  <hgroup>
    <h2>Primary Key Indexes</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>These indexes are such a good idea that databases routinely build them for us!</li>
<li>So you should not to build your won primary key indexes, <strong>ever</strong>
<br><br></li>
<li>If you use synthetic keys, then the comparison \(K_1 < K_2\) is probably not meaningful</li>
<li>I.e., all lookups will be based on equality (\(K1 = \dots\))</li>
<li>That means you should be using hash indexes on <em>synthetic</em> primary keys</li>
</ul>

<ul class = "build incremental">
<li>Hint: The default is usually a tree index</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-57" style="background:;">
  <hgroup>
    <h2>Clustered Indexes</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>An index is <strong>clustered</strong> if all the entries for a given value are on one (or just a very few) pages</li>
<li>Extreme case: If there&#39;s only one matching tuple, then of course it&#39;s on only one disk page</li>
<li>Another case: If the data is sorted on the index attributes, then it&#39;s clustered</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-58" style="background:;">
  <hgroup>
    <h2>Clustered Indexes</h2>
  </hgroup>
  <article data-timings="">
    <div class="centered">
    <img width="70%" src="assets/img/indexes-unclustered.png" title="Unclustered Index" alt="Unclustered Index">
    <br>    
    An Unclustered Index
</div>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-59" style="background:;">
  <hgroup>
    <h2>Clustered Indexes</h2>
  </hgroup>
  <article data-timings="">
    <div class="centered">
    <img width="70%" src="assets/img/indexes-clustered.png" title="Clustered Index" alt="Clustered Index">
    <br>    
    A Clustered Index
</div>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-60" style="background:;">
  <hgroup>
    <h2>Clustered Indexes</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>SELECT title, year
  FROM Movies
 WHERE year = 2000
</code></pre>

<ul>
<li>If the index is clustered, an index on year is very likely to be efficient

<ul>
<li>How likely depends on how <strong>selective</strong> year is in this table</li>
<li>I.e., if there are only movies from the year 2000, then the index is useless (selectivity 100%)</li>
<li>But if there are movies from all years from 1980-2010, then the index is good (selectivity \(\approx\) 3%)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-61" style="background:;">
  <hgroup>
    <h2>Clustered Indexes</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>SELECT title, year
  FROM Movies
 WHERE year = 2000
</code></pre>

<ul>
<li>If the index is unclustered, an index on year may be worse than useless

<ul>
<li>Even if there is data from 1980-2010, we still have to read each tuple separately</li>
<li>That means we need \(0.03 \times N\) disk I/Os</li>
<li>If a table holds more than 33 records, we would be better off ignoring the index!</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-62" style="background:;">
  <hgroup>
    <h2>Picking Indexes</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>It&#39;s hard to pick indexes in a vacuum</li>
<li>What you really need is a list of queries that are important to your application(s)</li>
<li>Also, these queries should be weighted, since some queries may be <strong>more important or frequent</strong> than others</li>
</ul>

<p><br></p>

<ul>
<li>With this information, you can compare the cost of implementing different indexes</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-63" style="background:;">
  <hgroup>
    <h2>Example</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Q1, with probability \(.6\)</li>
</ul>

<pre><code>SELECT movieTitle, movieYear
  FROM StarsIn
 WHERE starName = ?
</code></pre>

<ul>
<li>Q2, with probability \(.3\)</li>
</ul>

<pre><code>SELECT starName
  FROM StarsIn
 WHERE movieTitle = ? AND movieYear = ?
</code></pre>

<ul>
<li>Q3, with probability \(.1\)</li>
</ul>

<pre><code>INSERT INTO StarsIn VALUES(?,?,?)
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-64" style="background:;">
  <hgroup>
    <h2>Example (Assumptions)</h2>
  </hgroup>
  <article data-timings="">
    <ol>
<li>StarsIn takes up 10 pages</li>
<li>Typically, a star appears in 3 movies and each movie has 3 stars</li>
<li>The 3 movies a star is in will be in different pages of StarsIn, so it will take 3 disk I/Os 
to fetch these 3 movies, even with an index</li>
<li>1.5 disk accesses are required to read the index for an equality lookup</li>
<li>For inserts, we need 1 disk I/O to read the original page, 1 disk I/O to write the modified page,
and 2.5 disk I/Os to update the index (1.5 read, 1 write) -- for a total of 4.5 disk I/Os</li>
</ol>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-65" style="background:;">
  <hgroup>
    <h2>Example</h2>
  </hgroup>
  <article data-timings="">
    
<div style='float:left;width:48%;'>
  <table><thead>
<tr>
<th>Query</th>
<th>No Index</th>
<th>starName Index</th>
<th>movieTitle Index</th>
<th>Both Indexes</th>
</tr>
</thead><tbody>
<tr>
<td>Q1</td>
<td>10</td>
<td>4.5</td>
<td>10</td>
<td>4.5</td>
</tr>
<tr>
<td>Q2</td>
<td>10</td>
<td>10</td>
<td>4.5</td>
<td>4.5</td>
</tr>
<tr>
<td>Q3</td>
<td>2</td>
<td>4.5</td>
<td>4.5</td>
<td>7</td>
</tr>
<tr>
<td>Total</td>
<td>9.2</td>
<td>6.15</td>
<td>7.8</td>
<td>4.75</td>
</tr>
</tbody></table>

</div>
<div style='float:right;width:48%;'>
  <ul>
<li>Q1, with probability \(.6\)</li>
</ul>

<pre><code>SELECT movieTitle, movieYear
  FROM StarsIn
 WHERE starName = ?
</code></pre>

<ul>
<li>Q2, with probability \(.3\)</li>
</ul>

<pre><code>SELECT starName
  FROM StarsIn
 WHERE movieTitle = ? AND movieYear = ?
</code></pre>

<ul>
<li>Q3, with probability \(.1\)</li>
</ul>

<pre><code>INSERT INTO StarsIn VALUES(?,?,?)
</code></pre>

</div>
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-66" style="background:;">
  <hgroup>
    <h2>Example</h2>
  </hgroup>
  <article data-timings="">
    
<div style='float:left;width:48%;'>
  <table><thead>
<tr>
<th>Query</th>
<th>No Index</th>
<th>starName Index</th>
<th>movieTitle Index</th>
<th>Both Indexes</th>
</tr>
</thead><tbody>
<tr>
<td>Q1</td>
<td>10</td>
<td>4.5</td>
<td>10</td>
<td>4.5</td>
</tr>
<tr>
<td>Q2</td>
<td>10</td>
<td>10</td>
<td>4.5</td>
<td>4.5</td>
</tr>
<tr>
<td>Q3</td>
<td>2</td>
<td>4.5</td>
<td>4.5</td>
<td>7</td>
</tr>
<tr>
<td>Total</td>
<td>6</td>
<td>5.6</td>
<td>6.15</td>
<td>5.75</td>
</tr>
</tbody></table>

</div>
<div style='float:right;width:48%;'>
  <ul>
<li>Q1, with probability \(.3\)</li>
</ul>

<pre><code>SELECT movieTitle, movieYear
  FROM StarsIn
 WHERE starName = ?
</code></pre>

<ul>
<li>Q2, with probability \(.2\)</li>
</ul>

<pre><code>SELECT starName
  FROM StarsIn
 WHERE movieTitle = ? AND movieYear = ?
</code></pre>

<ul>
<li>Q3, with probability \(.5\)</li>
</ul>

<pre><code>INSERT INTO StarsIn VALUES(?,?,?)
</code></pre>

</div>
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-67" style="background:;">
  <hgroup>
    <h2>Picking Indexes Globally</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We only considered two indexes</li>
<li>But what if we had dozens of tables with dozens of attributes?</li>
</ul>

<p><br></p>

<ul>
<li>This is where automated tools coms in</li>
<li>A typical approach is to choose indexes <strong>greedily</strong>

<ol>
<li>First, fix a workload of queries</li>
<li>Consider the cost of executing these queries with no index</li>
<li>Now consider the cost of executing these queries with one (out of many possible) indexes</li>
<li>Pick the index that works best</li>
<li>Keep adding one index at a time, until it stops helping</li>
</ol></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

    <slide class="backdrop"></slide>
  </slides>
  <div class="pagination pagination-small" id='io2012-ptoc' style="display:none;">
    <ul>
      <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=1 title='NA'>
         1
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=2 title='Virtual Views'>
         2
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=3 title='Virtual Views'>
         3
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=4 title='Querying Virtual Views'>
         4
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=5 title='Querying Virtual Views'>
         5
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=6 title='Virtual Views to Simplify Queries'>
         6
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=7 title='Renaming Attributes'>
         7
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=8 title='Virtual Views to Secure Data'>
         8
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=9 title='Updating Views'>
         9
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=10 title='Updating Views'>
         10
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=11 title='Updating Views'>
         11
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=12 title='Removing Views'>
         12
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=13 title='Removing Views'>
         13
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=14 title='Updating Views'>
         14
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=15 title='Updating Views'>
         15
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=16 title='Updating Views'>
         16
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=17 title='Updatable Views'>
         17
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=18 title='Updating Updatable Views'>
         18
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=19 title='Inserting into an Updatable View'>
         19
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=20 title='Inserting into an Updatable View'>
         20
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=21 title='Deleting from an Updatable View'>
         21
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=22 title='Deleting from an Updatable View'>
         22
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=23 title='Updating an Updatable View'>
         23
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=24 title='Updatable Views'>
         24
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=25 title='INSTEAD OF Triggers'>
         25
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=26 title='Aside: Aspect-Oriented Programming'>
         26
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=27 title='Materialized Views'>
         27
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=28 title='Materialized Views'>
         28
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=29 title='Materialized Views'>
         29
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=30 title='Materialized Views'>
         30
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=31 title='Materialized Views'>
         31
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=32 title='Materialized Views'>
         32
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=33 title='Maintaining Materialized Views in Sync'>
         33
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=34 title='Maintaining Materialized Views in Sync'>
         34
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=35 title='Incremental Insertions'>
         35
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=36 title='Incremental Insertions'>
         36
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=37 title='Incremental Deletions'>
         37
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=38 title='Incremental Deletions'>
         38
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=39 title='Incremental Deletions'>
         39
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=40 title='Incremental Updates'>
         40
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=41 title='Indexes in SQL'>
         41
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=42 title='Indexes in SQL'>
         42
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=43 title='Indexes in SQL'>
         43
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=44 title='Motivation for indexes'>
         44
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=45 title='Motivation for indexes'>
         45
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=46 title='Motivation for indexes'>
         46
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=47 title='Motivation for indexes'>
         47
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=48 title='Declaring Indexes'>
         48
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=49 title='Multidimensional Indexes'>
         49
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=50 title='Dropping Indexes'>
         50
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=51 title='What Indexes to Pick?'>
         51
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=52 title='What Indexes to Pick?'>
         52
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=53 title='Basic Tradeoffs'>
         53
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=54 title='Primary Key Indexes'>
         54
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=55 title='Primary Key Indexes'>
         55
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=56 title='Primary Key Indexes'>
         56
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=57 title='Clustered Indexes'>
         57
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=58 title='Clustered Indexes'>
         58
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=59 title='Clustered Indexes'>
         59
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=60 title='Clustered Indexes'>
         60
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=61 title='Clustered Indexes'>
         61
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=62 title='Picking Indexes'>
         62
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=63 title='Example'>
         63
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=64 title='Example (Assumptions)'>
         64
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=65 title='Example'>
         65
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=66 title='Example'>
         66
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=67 title='Picking Indexes Globally'>
         67
      </a>
    </li>
  </ul>
  </div>  <!--[if IE]>
    <script 
      src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js">  
    </script>
    <script>CFInstall.check({mode: 'overlay'});</script>
  <![endif]-->
</body>
  <!-- Load Javascripts for Widgets -->
  <script src="libraries/widgets/bootstrap/js/bootstrap.min.js"></script>
<script src="libraries/widgets/bootstrap/js/bootbox.min.js"></script>

  <!-- MathJax: Fall back to local if CDN offline but local image fonts are not supported (saves >100MB) -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true
      }
    });
  </script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- <script src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script> -->
  <script>window.MathJax || document.write('<script type="text/x-mathjax-config">MathJax.Hub.Config({"HTML-CSS":{imageFont:null}});<\/script><script src="libraries/widgets/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"><\/script>')
</script>
<script>  
  $(function (){ 
    $("#example").popover(); 
    $("[rel='tooltip']").tooltip(); 
  });  
  </script>  
  <!-- LOAD HIGHLIGHTER JS FILES -->
  <script src="libraries/highlighters/highlight.js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <!-- DONE LOADING HIGHLIGHTER JS FILES -->
   
  </html>