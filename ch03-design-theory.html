<!DOCTYPE html>
<html>
<head>
  <title>COSC 4820 Database Systems</title>
  <meta charset="utf-8">
  <meta name="description" content="COSC 4820 Database Systems">
  <meta name="author" content="Ruben Gamboa">
  <meta name="generator" content="slidify" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/default.css" media="all" >
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/phone.css" 
    media="only screen and (max-device-width: 480px)" >
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/slidify.css" >
  <link rel="stylesheet" href="libraries/highlighters/highlight.js/css/tomorrow.css" />
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->  <link rel=stylesheet href="libraries/widgets/bootstrap/css/bootstrap.css"></link>
<link rel=stylesheet href="./assets/css/ribbons.css"></link>

  
  <!-- Grab CDN jQuery, fall back to local if offline -->
  <script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.7.min.js"></script>
  <script>window.jQuery || document.write('<script src="libraries/widgets/quiz/js/jquery.js"><\/script>')</script> 
  <script data-main="libraries/frameworks/io2012/js/slides" 
    src="libraries/frameworks/io2012/js/require-1.0.8.min.js">
  </script>
  
  

</head>
<body style="opacity: 0">
  <slides class="layout-widescreen">
    
    <!-- LOGO SLIDE -->
        <slide class="title-slide segue nobackground">
  <hgroup class="auto-fadein">
    <h1>COSC 4820 Database Systems</h1>
    <h2>Design Theory for Relational Databases</h2>
    <p>Ruben Gamboa<br/>Professor</p>
  </hgroup>
  <article></article>  
</slide>
    

    <!-- SLIDES -->
    <slide class="" id="slide-1" style="background:;">
  <article data-timings="">
    <style>
.title-slide {
     background-color: #EDE0CF; /* CBE7A5; #EDE0CF; ; #CA9F9D*/
     background-image: url(assets/img/uw-logo-large.png);
     background-repeat: no-repeat;
     background-position: center top;
   }
</style>

<h2>About this Chapter</h2>

<ul>
<li>The focus of this chapter is on <strong>designing database schemas</strong></li>
<li>This is the problem of <strong>modeling</strong></li>
<li>I.e., how do we represent the real world inside a database?
<br><br></li>
<li>Remember, all we have to work with is tables!</li>
<li>So how do we encode the real world in a bunch of tables?
<br><br></li>
<li>There are many pitfalls and traps</li>
<li>Luckily, there is a well understood theory of relational database design
<br><br></li>
<li>This is a very <strong>mathematical</strong> theory</li>
<li>But don&#39;t be fooled: It&#39;s tremendously useful</li>
<li>(Actually, that&#39;s the reason we study math -- it&#39;s tremendously useful!)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-2" style="background:;">
  <hgroup>
    <h1>Functional Dependencies</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-3" style="background:;">
  <hgroup>
    <h2>Functional Dependencies</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The most fundamental property to describe table design is that of <strong>functional dependency</strong></li>
<li>This is a generalization of the idea of <strong>(primary) key</strong>
<br><br></li>
<li>Consider a relation \(R(A,B,C)\)</li>
<li>We say that \(A\) is a key if

<ul>
<li>Suppose we know that \(A\) is equal to \(a\)</li>
<li>Then we also &quot;know&quot; the values of \(B\) and \(C\)</li>
</ul></li>
<li>By &quot;know&quot; \(B\) and \(C\), we mean that they are <strong>determined</strong> by the value of \(A\)
<br><br></li>
</ul>

<ul class = "build incremental">
<li>Similarly, we say that \(A\) <strong>functionally determines</strong> \(B\), written \(A \rightarrow B\), if

<ul>
<li>Suppose we know that \(A\) is equal to \(a\)</li>
<li>Then we also &quot;know&quot; the value of \(B\)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-4" style="background:;">
  <hgroup>
    <h2>Functional Dependency Sanity Check</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Check your understanding
<br><br></li>
<li>We have the relation \(R(A,B,C)\)
<br><br></li>
<li>\(A\) is a key if and only if \(A\) functionally determines \(B\) and \(C\)</li>
<li>I.e., \(A \rightarrow B, C\)
<br><br></li>
</ul>

<ul class = "build incremental">
<li>By the way, this can also be written as
\[\begin{eqnarray}
A & \rightarrow & B \\
A & \rightarrow & C \\
\end{eqnarray}
\]</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-5" style="background:;">
  <hgroup>
    <h2>A Sample Table</h2>
  </hgroup>
  <article data-timings="">
    <table><thead>
<tr>
<th>Title</th>
<th>Year</th>
<th>Length</th>
<th>Genre</th>
<th>StudioName</th>
<th>StarName</th>
</tr>
</thead><tbody>
<tr>
<td>Gone With the Wind</td>
<td>1939</td>
<td>231</td>
<td>drama</td>
<td>MGM</td>
<td>Vivien Leigh</td>
</tr>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>124</td>
<td>scifi</td>
<td>Fox</td>
<td>Mark Hamill</td>
</tr>
<tr>
<td>Wayne&#39;s World</td>
<td>1992</td>
<td>95</td>
<td>comedy</td>
<td>Paramount</td>
<td>Dana Carvey</td>
</tr>
</tbody></table>

<ul>
<li>Would you agree that \(\text{title}, \text{year} \rightarrow \text{length}\)?</li>
<li>How about \(\text{title}, \text{year} \rightarrow \text{genre}\)?</li>
<li>How about \(\text{title}, \text{year} \rightarrow \text{studioName}\)?</li>
<li>How about \(\text{title}, \text{year} \rightarrow \text{starName}\)?</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-6" style="background:;">
  <hgroup>
    <h2>Another Sample Table</h2>
  </hgroup>
  <article data-timings="">
    <table><thead>
<tr>
<th>Title</th>
<th>Year</th>
<th>Length</th>
<th>Genre</th>
<th>StudioName</th>
<th>StarName</th>
</tr>
</thead><tbody>
<tr>
<td>Gone With the Wind</td>
<td>1939</td>
<td>231</td>
<td>drama</td>
<td>MGM</td>
<td>Vivien Leigh</td>
</tr>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>124</td>
<td>scifi</td>
<td>Fox</td>
<td>Mark Hamill</td>
</tr>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>124</td>
<td>scifi</td>
<td>Fox</td>
<td>Carrie Fisher</td>
</tr>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>124</td>
<td>scifi</td>
<td>Fox</td>
<td>Harrison Ford</td>
</tr>
<tr>
<td>Wayne&#39;s World</td>
<td>1992</td>
<td>95</td>
<td>comedy</td>
<td>Paramount</td>
<td>Dana Carvey</td>
</tr>
<tr>
<td>Wayne&#39;s World</td>
<td>1992</td>
<td>95</td>
<td>comedy</td>
<td>Paramount</td>
<td>Mike Meyers</td>
</tr>
</tbody></table>

<ul>
<li>Would you agree that \(\text{title}, \text{year} \rightarrow \text{length}\)?</li>
<li>How about \(\text{title}, \text{year} \rightarrow \text{genre}\)?</li>
<li>How about \(\text{title}, \text{year} \rightarrow \text{studioName}\)?</li>
<li>How about \(\text{title}, \text{year} \rightarrow \text{starName}\)?</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-7" style="background:;">
  <hgroup>
    <h2>About Functional Dependencies and Relation Instances</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Functional dependencies are constraints on <strong>relations</strong></li>
<li>They are not constraints on <strong>relation instances</strong>
<br><br></li>
</ul>

<ul class = "build incremental">
<li><p>Trick question:</p>

<ul>
<li>Here&#39;s a relation instance</li>
<li>What are the keys?</li>
<li>What are the functional dependencies?
<br><br></li>
</ul></li>
<li><p>A relation instance can <strong>rule out</strong> a possible functional dependency</p></li>
<li><p>But it can never <strong>rule in</strong> a functional dependency</p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-8" style="background:;">
  <hgroup>
    <h2>A Formal Definition of Keys</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We now have the mathematical machinery to define formally what it means to be a key
<br><br></li>
<li>Suppose we have a relation \(R(A_1, A_2, \dots, A_n)\)</li>
<li>Let \(\mathcal{A} = \{A_1, A_2, \dots, A_n\}\)</li>
<li>Now, let \(\mathcal{S} \subset \mathcal{A}\)</li>
<li>I.e., \(\mathcal{S}\) is a subset of the attributes</li>
</ul>

<ul class = "build incremental">
<li><p>We say that \(\mathcal{S}\) is a <strong>key</strong> if and only if </p>

<ol>
<li>\(\mathcal{S} \rightarrow \mathcal{A} - \mathcal{S}\)</li>
<li>If \(\mathcal{S'} \subsetneq \mathcal{S}\), then \(\mathcal{S'} \nrightarrow \mathcal{A} - \mathcal{S'}\)</li>
</ol></li>
<li><p>If the first condition holds, we call \(\mathcal{S}\) a <strong>superkey</strong>, whether the second condition holds or not</p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-9" style="background:;">
  <hgroup>
    <h2>A Formal Definition of Keys</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have a relation \(R(A, B, C, D, E)\)</li>
<li>Suppose that

<ul>
<li>\(B \rightarrow C, D, E\)</li>
<li>\(C \rightarrow B, D, E\)</li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>\(\{A, B, C\}\) is a superkey, because \(A, B, C \rightarrow D, E\)</li>
<li><p>But it is not a key, because \(A, B \rightarrow C, D, E\) and \(\{A, B\} \subsetneq \{A, B, C\}\)</p></li>
<li><p>\(\{A, B\}\) is a key, because</p>

<ol>
<li>\(A, B \rightarrow C, D, E\)</li>
<li>\(A \nrightarrow B, C, D, E\)</li>
<li>\(B \nrightarrow A, C, D, E\)</li>
<li>\(\emptyset \nrightarrow A, B, C, D, E\) (and there&#39;s no need to check this, since it&#39;s implied by the previous two)</li>
</ol></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-10" style="background:;">
  <hgroup>
    <h2>A Formal Definition of Keys</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have a relation \(R(A, B, C, D, E)\)</li>
<li>Suppose that

<ul>
<li>\(B \rightarrow C, D, E\)</li>
<li>\(C \rightarrow B, D, E\)</li>
</ul></li>
<li>We already know that \(\{A, B\}\) is a key</li>
</ul>

<ul class = "build incremental">
<li>Similarly, \(\{A, C\}\) is also a key</li>
<li><p>We would choose either \(\{A, B\}\) or \(\{A, C\}\) as the primary key</p></li>
<li><p>There are many (10) superkeys, but no more keys</p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-11" style="background:;">
  <hgroup>
    <h1>Rules about Functional Dependencies</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-12" style="background:;">
  <hgroup>
    <h2>Reasoning about Functional Dependencies</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we know that \(A \rightarrow B\)</li>
<li>And we also know that \(B \rightarrow C\)</li>
</ul>

<ul class = "build incremental">
<li>Isn&#39;t it obvious that \(A \rightarrow C\)?</li>
<li><p>That&#39;s the idea behind reasoning about functional dependencies</p></li>
<li><p>In general, we can say that a particular set \(S\) of FDs implies some other FD \(F\), which we write as \(S \vdash F\)</p></li>
<li><p>Or a set \(S\) of functional dependencies may imply some other set \(T\) of FDs, which we write as \(S \vdash T\)</p>

<ul>
<li>In this case, We also say that \(T\) follows from \(S\)</li>
</ul></li>
<li><p>And, whenever \(S \vdash T\) and \(T \vdash S\), we say that \(S\) and \(T\) are <strong>equivalent</strong></p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-13" style="background:;">
  <hgroup>
    <h2>Splitting Rule</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we know that \(A \rightarrow B, C\)</li>
</ul>

<ul class = "build incremental">
<li>We can write this instead as

<ol>
<li>\(A \rightarrow B\)</li>
<li>\(A \rightarrow C\)</li>
</ol></li>
<li>In fact, we sometimes prefer to write FDs so that they only have one attribute on the right-hand side</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-14" style="background:;">
  <hgroup>
    <h2>Combining Rule</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li><p>We can go the other way</p></li>
<li><p>Suppose we know that </p>

<ol>
<li>\(A \rightarrow B\)</li>
<li>\(A \rightarrow C\)</li>
</ol></li>
</ul>

<ul class = "build incremental">
<li>We can write this instead as \(A \rightarrow B, C\)</li>
<li>And for some purposes, we want to write FDs to have the maximum number of attributes on the right-hand side</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-15" style="background:;">
  <hgroup>
    <h2>Trivial Functional Dependencies</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have a relation \(R(A, B, C)\)</li>
</ul>

<ul class = "build incremental">
<li><p>Then all of these hold</p>

<ol>
<li>\(A \rightarrow A\)</li>
<li>\(B \rightarrow B\)</li>
<li>\(A, B, C \rightarrow A\)</li>
</ol></li>
<li><p>More formally, if \(\mathcal{A}\) is the set of attributes of relation \(R\), then</p>

<ul>
<li>\(\mathcal{A}' \rightarrow \mathcal{A}''\) whenever \(\mathcal{A}'' \subset \mathcal{A}' \subset \mathcal{A}\)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-16" style="background:;">
  <hgroup>
    <h2>Trivial Dependency Rule</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have a relation \(R(A, B, C)\)</li>
<li>And suppose that \(A, B \rightarrow B, C\)</li>
</ul>

<ul class = "build incremental">
<li>This is not a trivial dependency, but there&#39;s something strange about it</li>
<li><p>In fact, it is easy to see that \(A, B \rightarrow C\) is a simpler version that is equivalent to it</p></li>
<li><p>More formally, if \(\mathcal{A}\) is the set of attributes of relation \(R\), and \(\mathcal{A'} \rightarrow \mathcal{A''}\)</p>

<ul>
<li>\(\mathcal{A}' \rightarrow \mathcal{A}'' - \mathcal{A'}\)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-17" style="background:;">
  <hgroup>
    <h2>Closure of a Set of Attributes</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have a relation \(R\) with attributes \(\mathcal{A}\)</li>
<li><p>Let \(\{A_1, A_2, \dots, A_n\} \subset \mathcal{A}\)</p></li>
<li><p>The <strong>closure</strong> of \(\{A_1, A_2, \dots, A_n\}\), written \(\{A_1, A_2, \dots, A_n\}^+\) is the set of all attributes that
are functionally determined by \(\{A_1, A_2, \dots, A_n\}\)</p></li>
<li><p>Notice that \(\{A_1, A_2, \dots, A_n\} \subset \{A_1, A_2, \dots, A_n\}^+\), because of trivial FDs</p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-18" style="background:;">
  <hgroup>
    <h2>Closure of a Set of Attributes</h2>
  </hgroup>
  <article data-timings="">
    <p class="centered">
    <img src="assets/img/closure-attributes.png" alt="Closure of a Set of Attributes" title="Closure of a Set of Attributes" class="img-responsive">
</p>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-19" style="background:;">
  <hgroup>
    <h2>Closure of a Set of Attributes</h2>
  </hgroup>
  <article data-timings="">
    <p>INPUT: A set \(A\) of attributes of a relation \(R\), and a set \(S\) of FDs </p>

<p>OUTPUT: \(A^+\)</p>

<ol>
<li>Use the splitting on rule on \(S\), so that all FDs have a single attribute on the right-hand side</li>
<li>Let \(X\) be the set of attributes that will become the closure</li>
<li>Initially, \(X=A\)</li>
<li>While there is some FD \(B_1, B_2, \dots, B_m \rightarrow C\) such that \(\{B_1, B_2, \dots, B_m\} \subset X\) but \(C \not\in X\)

<ol>
<li>Let \(X = X \cup \{C\}\)</li>
</ol></li>
</ol>

<p><br>
Note that this algorithm terminates</p>

<ul>
<li>At each step in the loop, \(X\) grows by one attribute</li>
<li>\(X\) can be no larger than the attributes of \(R\)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-20" style="background:;">
  <hgroup>
    <h2>Example</h2>
  </hgroup>
  <article data-timings="">
    <p>Suppose we have a relation \(R(A,B,C,D,E,F)\) with the following FDs:</p>

<ul>
<li>\(A, B \rightarrow C\)</li>
<li>\(B, C \rightarrow A, D\)</li>
<li>\(D \rightarrow E\)</li>
<li>\(C, F \rightarrow B\)</li>
</ul>

<p>Let&#39;s find the closure of \(\{A, B\}\)</p>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-21" style="background:;">
  <hgroup>
    <h2>Example</h2>
  </hgroup>
  <article data-timings="">
    <p>Step 1: Use the splitting rule, and replace the FDs with:</p>

<ul>
<li>\(A, B \rightarrow C\)</li>
<li>\(B, C \rightarrow A\)</li>
<li>\(B, C \rightarrow D\)</li>
<li>\(D \rightarrow E\)</li>
<li>\(C, F \rightarrow B\)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-22" style="background:;">
  <hgroup>
    <h2>Example</h2>
  </hgroup>
  <article data-timings="">
    
<div style='float:left;width:48%;'>
  <h3>Functional Dependencies</h3>

<ul>
<li>\(A, B \rightarrow C\)</li>
<li>\(B, C \rightarrow A\)</li>
<li>\(B, C \rightarrow D\)</li>
<li>\(D \rightarrow E\)</li>
<li>\(C, F \rightarrow B\)</li>
</ul>

</div>
<div style='float:right;width:48%;'>
  <h3>Algorithm Trace</h3>

<table><thead>
<tr>
<th>Step</th>
<th>\(X\)</th>
<th>FD</th>
</tr>
</thead><tbody>
<tr>
<td>0</td>
<td>\(A, B\)</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>\(A, B, C\)</td>
<td>\(A, B \rightarrow C\)</td>
</tr>
<tr>
<td>2</td>
<td>\(A, B, C, D\)</td>
<td>\(B, C \rightarrow D\)</td>
</tr>
<tr>
<td>3</td>
<td>\(A, B, C, D, E\)</td>
<td>\(D \rightarrow E\)</td>
</tr>
</tbody></table>

</div>
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-23" style="background:;">
  <hgroup>
    <h2>Why the Closure Algorithm Works, Part 1</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose that we have a set \(A\) of attributes from a relation \(R\)</li>
<li>The closure algorithm returns \(X\)</li>
<li>We claim that \(X \subset A^+\)
<br><br></li>
<li>By induction on the number of steps</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-24" style="background:;">
  <hgroup>
    <h2>Why the Closure Algorithm Works, Part 1</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li><strong>Basis:</strong> If there are 0 steps, then \(X=A\), so it follows that \(A \subset A^+\)
<br><br></li>
<li><strong>Induction:</strong>

<ul>
<li>Suppose \(B \in X\)</li>
<li>\(B\) was added because of some FD \(B_1, B_2, \dots, B_n \rightarrow B\)</li>
<li>By the inductive hypothesis, all of the \(B_i\) are in \(X\) and in \(A^+\)</li>
<li>So \(R\) satisfies \(A \rightarrow B_1, B_2, \dots, B_n\)</li>
<li>If \(R\) has two tuples with the same values of \(A\), then they must also have the values of \(B_1, B_2, \dots, B_n\)</li>
<li>And since \(R\) satisfies \(B_1, B_2, \dots, B_n \rightarrow B\), those two tuples also have the same values of \(B\)</li>
<li>So \(A \rightarrow B\) and \(B \in A^+\)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-25" style="background:;">
  <hgroup>
    <h2>Why the Closure Algorithm Works, Part 2</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose that we have a set \(A\) of attributes from a relation \(R\)</li>
<li>The closure algorithm returns \(X\)</li>
<li>We claim that \(A^+ \subset X\)</li>
<li>Which means that \(A = X^+\) (from Part 1)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-26" style="background:;">
  <hgroup>
    <h2>Why the Closure Algorithm Works, Part 2</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose that \(B \not\in X\)</li>
<li>We need to show that \(A_1, A_2, \dots, A_n \rightarrow B\) does not hold</li>
<li>To do this, we create a relation instance for \(R\) in which this FD does not hold</li>
<li>The instance has two tuples

<ul>
<li>\(t\): 1&#39;s on all attributes in \(X\), and 0&#39;s on all other attributes</li>
<li>\(s\): 1&#39;s on all attributes</li>
</ul></li>
<li>Notice that \(t\) and \(s\) agree on an attribute \(C\) if and only \(C \in X\)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-27" style="background:;">
  <hgroup>
    <h2>Why the Closure Algorithm Works, Part 2</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The instance has two tuples

<ul>
<li>\(t\): 1&#39;s on all attributes in \(X\), and 0&#39;s on all other attributes</li>
<li>\(s\): 1&#39;s on all attributes</li>
</ul></li>
<li>We claim that this instance satisfies all of the FDs in \(S\)
<br><br></li>
<li>Consider some FD \(C_1, C_2, \dots, C_k \rightarrow D\) in \(S\)</li>
<li>If one of the \(C_i\) is not in \(X\), then this FD is satisfied</li>
<li>If \(D\) is in \(X\), then this FD is also satisfied, and we&#39;re done</li>
<li>Otherwise, the algorithm would have added \(D\) to \(X\) because of this FD</li>
<li>So we conclude that this case cannot happen</li>
<li>I.e., the instance satisfies all of the FDs in \(S\)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-28" style="background:;">
  <hgroup>
    <h2>Why the Closure Algorithm Works, Part 2</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The instance has two tuples

<ul>
<li>\(t\): 1&#39;s on all attributes in \(X\), and 0&#39;s on all other attributes</li>
<li>\(s\): 1&#39;s on all attributes</li>
</ul></li>
<li>We claim that this instance does not satisfy the FD \(A_1, A_2, \dots, A_n \rightarrow B\)
<br><br></li>
<li>But this is easy</li>
<li>All the \(A_i\) are in \(X\), so the tuples \(t\) and \(s\) agree on those values</li>
<li>But we know that \(B\) is not in \(X\), so \(t\) and \(s\) disagree on \(B\)</li>
<li>That means that this instance does not satisfy the FD \(A_1, A_2, \dots, A_n \rightarrow B\)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-29" style="background:;">
  <hgroup>
    <h2>Why the Closure Algorithm Works, Part 2</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have a table \(R\), a subset of the attributes \(A\), and some functional dependencies \(F\)</li>
<li>If we run the closure algorithm on \(A\), we get a result \(X\)</li>
<li>For each \(B \in X\), we know that \(A \rightarrow B\)</li>
<li>And for any \(C \not\in X\), we know that \(A \nrightarrow B\)
<br><br></li>
<li>In other words, \(X = A^+\)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-30" style="background:;">
  <hgroup>
    <h2>Example: Transitive Rule</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The <strong>transitive rule</strong> says that if \(\mathcal{A} \rightarrow \mathcal{B}\) and \(\mathcal{B} \rightarrow \mathcal{C}\),
then \(\mathcal{A} \rightarrow \mathcal{C}\)</li>
<li>Remember that \(\mathcal{A}\), \(\mathcal{B}\), and \(\mathcal{C}\) are all <strong>sets</strong> of attributes
<br><br></li>
<li>It&#39;s easy to see that this rule holds using the closure algorithm</li>
<li>We know that \(\mathcal{A}^+\) must include \(\mathcal{B}\)</li>
<li>I.e., \(\mathcal{B} \subset \mathcal{A}^+\)
<br><br></li>
<li>But then, using \(\mathcal{B} \rightarrow \mathcal{C}\), we see that \(\mathcal{A}^+\) must include \(\mathcal{C}\)</li>
<li>I.e., \(\mathcal{C} \subset \mathcal{A}^+\)
<br><br></li>
<li>So indeed, \(\mathcal{A} \rightarrow \mathcal{C}\) holds</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-31" style="background:;">
  <hgroup>
    <h2>All the (Needed) Inference Rules</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We&#39;ve seen trivial rules and transitivity</li>
<li><p>Here is a full set of inference rules</p>

<ol>
<li><strong>Reflexivity.</strong> This is just a fancy name for trivial rules</li>
<li><strong>Augmentation.</strong> If \(\mathcal{A} \rightarrow \mathcal{B}\), then \(\mathcal{A}, \mathcal{C} \rightarrow \mathcal{B}, \mathcal{C}\)</li>
<li><strong>Transitivity.</strong> \(\mathcal{A} \rightarrow \mathcal{B}\) and \(\mathcal{B} \rightarrow \mathcal{C}\),
then \(\mathcal{A} \rightarrow \mathcal{C}\)</li>
</ol></li>
<li><p>That&#39;s it!</p></li>
<li><p>All valid inference rules for FDs follow from the above!</p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-32" style="background:;">
  <hgroup>
    <h2>Minimal Functional Dependencies</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>An important application of the inference rules for FDs is the idea of <strong>minimal basis</strong>
<br><br></li>
<li>Suppose \(S\) is a set of FDs</li>
<li>If some other set \(S'\) of FDs is equivalent to \(S\), we call \(S'\) a <strong>basis</strong> for \(S\)</li>
<li>We restrict ourselves here to bases that have FDs with only one attribute on the right-hand sides
<br></li>
</ul>

<ul class = "build incremental">
<li>A <strong>minimal basis</strong> is a basis \(S'\) where

<ol>
<li>All FDs have singleton right-hand sides</li>
<li>If any FD is removed from \(S'\), the result is no longer a basis</li>
<li>If any attribute is removed from the left-hand side of any FD in \(S'\), the result is not a basis</li>
</ol></li>
<li>I.e., we need all the FDs, and no FD can be smaller</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-33" style="background:;">
  <hgroup>
    <h2>Functional Dependencies and Projections</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose that \(S\) is a set of FDs for relation \(R\)
<br><br></li>
<li>What are the FDs for \(\pi_{\mathcal{B}}(R)\), where \(\mathcal{B}\) is some subset of the attributes of \(R\)?
<br></li>
</ul>

<ul class = "build incremental">
<li><p>We can follow the <strong>projection of functional dependencies</strong> \(S'\), which are all syntactically valid FDs such that</p>

<ol>
<li>they follow from \(S\)</li>
<li>they involve only attributes in \(\mathcal{B}\)</li>
</ol></li>
<li><p>Note that we&#39;re talking about FDs that <strong>follow from</strong> \(S\)</p></li>
<li><p>This is not the same as the FDs in \(S\)</p>

<ul>
<li>Consider \(R(A,B,C)\) with FDs \(A \rightarrow B\), \(B \rightarrow C\), and think of \(\pi_{A,C}(R)\)</li>
</ul></li>
<li><p>Because of this, the algorithm is actually complex (and expensive)</p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-34" style="background:;">
  <hgroup>
    <h2>Projection of Functional Dependencies</h2>
  </hgroup>
  <article data-timings="">
    <p>INPUT: A relation \(R\), a set of attributes \(\mathcal{B}\), and a set (basis) of FDs \(S\) for \(R\)</p>

<p>OUTPUT: A set (basis) \(S'\) of FDs for \(\pi_{\mathcal{B}}(R)\)</p>

<ol>
<li>\(S' = \emptyset\)</li>
<li>For each \(X \subset \mathcal{B}\)

<ol>
<li>Compute \(X^+\) using \(S\)</li>
<li>For each \(A \in X^+ \cap \mathcal{B}\)

<ol>
<li>Add \(X \rightarrow A\) to \(S'\)</li>
</ol></li>
</ol></li>
<li>Repeat until no more changes can be made

<ol>
<li>If there is an FD in \(S'\) that follows from the other FDs in \(S'\), remove it</li>
<li>If there is an FD \(LHS \rightarrow B\) in \(S'\) such that after removing an attribute \(A\) from \(LHS\), the resulting
FD \(LHS - A \rightarrow B\) still follows from \(S'\), then replace \(LHS \rightarrow B\) with \(LHS - A \rightarrow B\)</li>
</ol></li>
<li>Return \(S'\)</li>
</ol>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-35" style="background:;">
  <hgroup>
    <h2>Projection of Functional Dependencies and Pragmatics</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The algorithm is OK if you&#39;re a computer</li>
<li>But it&#39;s very expensive, i.e., the loop iterates over <strong>all subsets</strong> of \(\mathcal{B}\)</li>
</ul>

<ul class = "build incremental">
<li>As a practical matter, we use these observations

<ul>
<li>Don&#39;t worry about the empty set or the set \(\mathcal{B}\) (but that still leaves \(2^n - 2\) subsets)</li>
<li>Once we find that \(X^+ \rightarrow Y\), there&#39;s no point in considering supersets of \(X\) for attributes already in \(Y\)</li>
<li>In particular, if \(X^+ \rightarrow \mathcal{B}\), then we can ignore all supersets of \(X\)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-36" style="background:;">
  <hgroup>
    <h1>Design of Relational Database Schemas</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-37" style="background:;">
  <hgroup>
    <h2>Designing Relational Database Schemas</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose you want to model some real-world situation in a relational database</li>
<li>Chances are there will be more than one way to do it
<br><br></li>
<li>And some ways <strong>will be better</strong> than others!
<br><br></li>
<li>This is not a matter of opinion</li>
<li>This is a <strong>technical</strong> matter</li>
<li>There can be <strong>technical</strong> problems with a database schema</li>
<li>The problems are called <strong>anomalies</strong>
<br><br></li>
<li>The root of all evil is usually <strong>redundancy</strong></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-38" style="background:;">
  <hgroup>
    <h2>Anomalies</h2>
  </hgroup>
  <article data-timings="">
    <table><thead>
<tr>
<th>Title</th>
<th>Year</th>
<th>Length</th>
<th>Genre</th>
<th>StudioName</th>
<th>StarName</th>
</tr>
</thead><tbody>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>124</td>
<td>scifi</td>
<td>Fox</td>
<td>Carrie Fisher</td>
</tr>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>124</td>
<td>scifi</td>
<td>Fox</td>
<td>Mark Hamill</td>
</tr>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>124</td>
<td>scifi</td>
<td>Fox</td>
<td>Harrison Ford</td>
</tr>
<tr>
<td>Gone With the Wind</td>
<td>1939</td>
<td>231</td>
<td>drama</td>
<td>MGM</td>
<td>Vivien Leigh</td>
</tr>
<tr>
<td>Wayne&#39;s World</td>
<td>1992</td>
<td>95</td>
<td>comedy</td>
<td>Paramount</td>
<td>Dana Carvey</td>
</tr>
<tr>
<td>Wayne&#39;s World</td>
<td>1992</td>
<td>95</td>
<td>comedy</td>
<td>Paramount</td>
<td>Mike Meyers</td>
</tr>
</tbody></table>

<p><br></p>

<ul>
<li><strong>Redundancy:</strong> Information is stored in multiple places</li>
<li><strong>Update Anomalies:</strong> Information is updated in one place, but not in others</li>
<li><strong>Deletion Anomalies:</strong> When some rows are deleted, we unexpectedly lose extra information</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-39" style="background:;">
  <hgroup>
    <h2>Decompositions</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The solution to the anomalies is <strong>decomposition</strong></li>
<li>Suppose \(R\) is a relation with attributes \(\mathcal{A}\)</li>
<li>Let \(\mathcal{B}\) and \(\mathcal{C}\) be subsets of \(\mathcal{A}\) that cover \(\mathcal{A}\)

<ul>
<li>\(\mathcal{B} \subset \mathcal{A}\)</li>
<li>\(\mathcal{C} \subset \mathcal{A}\)</li>
<li>\(\mathcal{B} \cup \mathcal{C} = \mathcal{A}\)</li>
</ul></li>
<li>Then \(R\) can be decomposed into

<ul>
<li>\(R_1 = \pi_{\mathcal{B}}(R)\)</li>
<li>\(R_2 = \pi_{\mathcal{C}}(R)\)
<br><br></li>
</ul></li>
<li>In general, we may decompose \(R\) into \(k\) different relations \(R_1, R_2, \dots, R_k\)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-40" style="background:;">
  <hgroup>
    <h2>Decompositions</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>For example, suppose we have the relation \(R(A,B,C)\)
<br><br></li>
<li>One possible decomposition is

<ul>
<li>\(R_1(A, B)\)</li>
<li>\(R_2(B, C)\)
<br><br></li>
</ul></li>
<li>Of course, there are many other possible decompositions!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-41" style="background:;">
  <hgroup>
    <h2>Decompositions</h2>
  </hgroup>
  <article data-timings="">
    <table><thead>
<tr>
<th>Title</th>
<th>Year</th>
<th>Length</th>
<th>Genre</th>
<th>StudioName</th>
<th>StarName</th>
</tr>
</thead><tbody>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>124</td>
<td>scifi</td>
<td>Fox</td>
<td>Carrie Fisher</td>
</tr>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>124</td>
<td>scifi</td>
<td>Fox</td>
<td>Mark Hamill</td>
</tr>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>124</td>
<td>scifi</td>
<td>Fox</td>
<td>Harrison Ford</td>
</tr>
<tr>
<td>Gone With the Wind</td>
<td>1939</td>
<td>231</td>
<td>drama</td>
<td>MGM</td>
<td>Vivien Leigh</td>
</tr>
<tr>
<td>Wayne&#39;s World</td>
<td>1992</td>
<td>95</td>
<td>comedy</td>
<td>Paramount</td>
<td>Dana Carvey</td>
</tr>
<tr>
<td>Wayne&#39;s World</td>
<td>1992</td>
<td>95</td>
<td>comedy</td>
<td>Paramount</td>
<td>Mike Meyers</td>
</tr>
</tbody></table>

<p><br></p>

<div style='float:left;width:48%;'>
  <table><thead>
<tr>
<th>Title</th>
<th>Year</th>
<th>StarName</th>
</tr>
</thead><tbody>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>Carrie Fisher</td>
</tr>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>Mark Hamill</td>
</tr>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>Harrison Ford</td>
</tr>
<tr>
<td>Gone With the Wind</td>
<td>1939</td>
<td>Vivien Leigh</td>
</tr>
<tr>
<td>Wayne&#39;s World</td>
<td>1992</td>
<td>Dana Carvey</td>
</tr>
<tr>
<td>Wayne&#39;s World</td>
<td>1992</td>
<td>Mike Meyers</td>
</tr>
</tbody></table>

</div>
<div style='float:right;width:48%;'>
  <table><thead>
<tr>
<th>Title</th>
<th>Year</th>
<th>Length</th>
<th>Genre</th>
<th>StudioName</th>
</tr>
</thead><tbody>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>124</td>
<td>scifi</td>
<td>Fox</td>
</tr>
<tr>
<td>Gone With the Wind</td>
<td>1939</td>
<td>231</td>
<td>drama</td>
<td>MGM</td>
</tr>
<tr>
<td>Wayne&#39;s World</td>
<td>1992</td>
<td>95</td>
<td>comedy</td>
<td>Paramount</td>
</tr>
</tbody></table>

</div>
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-42" style="background:;">
  <hgroup>
    <h2>Boyce-Codd Normal Form (BCNF)</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li><strong>Boyce-Codd Normal Form</strong> (BCNF) is a condition that can tell us when a schema does not suffer from anomalies
<br><br></li>
<li>A relation \(R\) is in BCNF if

<ul>
<li>for each nontrivial FD \(X \rightarrow A\), the left-hand side \(X\) is a superkey for \(R\)
<br><br></li>
</ul></li>
<li>That is, the left-hand side of every FD must contain a key
<br><br></li>
</ul>

<ul class = "build incremental">
<li>If there are more than one key, the requirement is for the FD to contain <strong>one of them</strong></li>
<li>It is not necessary for the FD to contain all keys</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-43" style="background:;">
  <hgroup>
    <h2>Boyce-Codd Normal Form (BCNF)</h2>
  </hgroup>
  <article data-timings="">
    <table><thead>
<tr>
<th>Title</th>
<th>Year</th>
<th>Length</th>
<th>Genre</th>
<th>StudioName</th>
<th>StarName</th>
</tr>
</thead><tbody>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>124</td>
<td>scifi</td>
<td>Fox</td>
<td>Carrie Fisher</td>
</tr>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>124</td>
<td>scifi</td>
<td>Fox</td>
<td>Mark Hamill</td>
</tr>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>124</td>
<td>scifi</td>
<td>Fox</td>
<td>Harrison Ford</td>
</tr>
<tr>
<td>Gone With the Wind</td>
<td>1939</td>
<td>231</td>
<td>drama</td>
<td>MGM</td>
<td>Vivien Leigh</td>
</tr>
<tr>
<td>Wayne&#39;s World</td>
<td>1992</td>
<td>95</td>
<td>comedy</td>
<td>Paramount</td>
<td>Dana Carvey</td>
</tr>
<tr>
<td>Wayne&#39;s World</td>
<td>1992</td>
<td>95</td>
<td>comedy</td>
<td>Paramount</td>
<td>Mike Meyers</td>
</tr>
</tbody></table>

<p><br></p>

<ul>
<li>Not in BCNF</li>
<li>The key is title, year, starName</li>
<li>But there is an FD title, year \(\rightarrow\) Length
<br><br></li>
<li>Notice that to tell if \(R\) is in BCNF, you must be able to find the keys for \(R\) first</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-44" style="background:;">
  <hgroup>
    <h2>Boyce-Codd Normal Form (BCNF)</h2>
  </hgroup>
  <article data-timings="">
    <table><thead>
<tr>
<th>Title</th>
<th>Year</th>
<th>Length</th>
<th>Genre</th>
<th>StudioName</th>
</tr>
</thead><tbody>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>124</td>
<td>scifi</td>
<td>Fox</td>
</tr>
<tr>
<td>Gone With the Wind</td>
<td>1939</td>
<td>231</td>
<td>drama</td>
<td>MGM</td>
</tr>
<tr>
<td>Wayne&#39;s World</td>
<td>1992</td>
<td>95</td>
<td>comedy</td>
<td>Paramount</td>
</tr>
</tbody></table>

<p><br></p>

<ul>
<li>This is in BCNF</li>
<li>The key is title, year</li>
<li>The only real nontrivial FD is title, year \(\rightarrow\) length, genre, studioName
<br><br></li>
<li>All other FDs must include title, year in the left-hand side</li>
<li>So all FDs include a key in the left-hand-side</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-45" style="background:;">
  <hgroup>
    <h2>Boyce-Codd Normal Form (BCNF)</h2>
  </hgroup>
  <article data-timings="">
    <table><thead>
<tr>
<th>Title</th>
<th>Year</th>
<th>StarName</th>
</tr>
</thead><tbody>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>Carrie Fisher</td>
</tr>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>Mark Hamill</td>
</tr>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>Harrison Ford</td>
</tr>
<tr>
<td>Gone With the Wind</td>
<td>1939</td>
<td>Vivien Leigh</td>
</tr>
<tr>
<td>Wayne&#39;s World</td>
<td>1992</td>
<td>Dana Carvey</td>
</tr>
<tr>
<td>Wayne&#39;s World</td>
<td>1992</td>
<td>Mike Meyers</td>
</tr>
</tbody></table>

<p><br></p>

<ul>
<li>Again, this is in BCNF</li>
<li>The key is title, year, StarName</li>
<li>There are no nontrivial FDs</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-46" style="background:;">
  <hgroup>
    <h2>Decomposing into BCNF</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We now have a goal</li>
<li>We want to <strong>turn a schema into BCNF</strong>
<br><br></li>
<li>We can do this by <strong>decomposition</strong></li>
<li>With care, we can decompose any relation \(R\) into a set of relations \(R_1, R_2, \dots, R_k\) such that

<ul>
<li>the \(R_i\) are all in BCNF</li>
<li>the data in \(R\) can be reproduced from the data in the \(R_i\)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-47" style="background:;">
  <hgroup>
    <h2>Decomposing into BCNF</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The trick is to use the FDs of \(R\) to guide its decomposition
<br><br></li>
<li>Consider <code>Movies(title, year, length, genre, studioName, starName)</code></li>
<li>The key is <code>title, year, starName</code></li>
<li>But we have an FD <code>title, year</code> \(\rightarrow\) <code>length, genre, studioName</code></li>
<li>This is a BCNF violation
<br><br></li>
<li>We fix the violation by decomposing <code>Movies</code> into

<ul>
<li><code>Movies1(title, year, length, genre, studioName)</code> </li>
<li><code>Movies2(title, year, starName)</code> </li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-48" style="background:;">
  <hgroup>
    <h2>Decomposing into BCNF</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The FD <code>title, year</code> \(\rightarrow\) <code>length, genre, studioName</code> suggested decomposing
<code>Movies(title, year, length, genre, studioName, starName)</code> into

<ul>
<li><code>Movies1(title, year, length, genre, studioName)</code> </li>
<li><code>Movies2(title, year, starName)</code> 
<br><br></li>
</ul></li>
<li>This follows a simple strategy

<ul>
<li><code>Movies1</code>: All attributes from \(LHS \rightarrow RHS\)</li>
<li><code>Movies2</code>: Attributes from \(LHS\) and any attribute not in \(RHS\)
<br><br></li>
</ul></li>
<li>Repeatedly applying this strategy guarantees that we&#39;ll end up with a schema in BCNF</li>
<li><strong>Judicious</strong> use of this strategy ensures that we end up with a reasonable schema, 
i.e., one with a small number of relations</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-49" style="background:;">
  <hgroup>
    <h2>Decomposing into BCNF</h2>
  </hgroup>
  <article data-timings="">
    <p>INPUT: A relation \(R\) with attributes \(\mathcal{A}\) and a set of FDs \(S\)</p>

<p>OUTPUT: A decomposition of \(R\) into relations \(R_1, R_2, \dots, R_n\), all of which are in BCNF</p>

<ol>
<li>If \(R\) is in BCNF, return \(\{R\}\)</li>
<li>Let \(X \rightarrow Y\) be a FD in \(S\) that violates BCNF</li>
<li>Decompose \(R\) into \(R_1(X^+)\) and \(R_2(X, \mathcal{A}-X^+)\)</li>
<li>Let \(S_1\) be the projection of the FDs \(S\) for \(R_1\)</li>
<li>Let \(S_2\) be the projection of the FDs \(S\) for \(R_2\)</li>
<li>Recursively decompose \(R_1\) with \(S_1\) into a set of BCNF relations</li>
<li>Recursively decompose \(R_2\) with \(S_2\) into a set of BCNF relations</li>
<li>Return the union of the decompositions of \(R_1\) and \(R_2\)</li>
</ol>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-50" style="background:;">
  <hgroup>
    <h2>Decomposing into BCNF</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Why does this algorithm terminate?</li>
</ul>

<ul class = "build incremental">
<li>When it calls itself recursively after decomposing on \(X \rightarrow Y\), it always does with a smaller relation

<ul>
<li>\(R_1(X^+)\) has fewer attributes than \(R\); otherwise, \(X\) would be a key for \(R\) and there is no BCNF violation</li>
<li>\(R_2(X, \mathcal{A}-X^+)\) also has fewer attributes than \(R\), since \(Y\in X^+\) but \(Y \not\in X\)</li>
</ul></li>
<li>And when we get to binary relations, we&#39;re done</li>
<li>All binary relations are in BCNF!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-51" style="background:;">
  <hgroup>
    <h1>Consequences of Decomposition into BCNF</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-52" style="background:;">
  <hgroup>
    <h2>(Wanted) Properties of BCNF Decomposition</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We start with a relation \(R\) and decompose it into \(R_1, R_2, \dots, R_n\), all of which are in BCNF
<br><br></li>
<li>What properties do we want of this decomposition?
<br><br></li>
</ul>

<ol>
<li><strong>No anomalies</strong> in the \(R_i\)</li>
<li><strong>Recoverability of information</strong>, meaning that we can recreate \(R\) from the \(R_i\)</li>
<li><strong>Preservation of dependencies</strong>, meaning that any FD about \(R\) somehow translates into FDs for some of the \(R_i\)
<br><br></li>
</ol>

<ul class = "build incremental">
<li>With BCNF decomposition, we get the first two, but not necessarily the third</li>
<li>Actually, you can&#39;t (always) get all three properties with any decomposition strategy!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-53" style="background:;">
  <hgroup>
    <h2>No Anomalies: Redundancy</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Consider any of the \(R_i\)</li>
<li>It&#39;s in BCNF</li>
<li>Let&#39;s say the key is \(A\), and \(X\) and \(Y\) are two <strong>other</strong> attributes</li>
<li>Consider any row of \(R_i\)</li>
<li>It is possible to have another row with the same value of \(X\) but a different value of \(Y\)</li>
<li>This is because \(X \rightarrow Y\) cannot be a FD</li>
<li>So there are no redundancies</li>
<li>The same value may appear in multiple cells, but <strong>not because it has to</strong></li>
<li>I.e., any repeated values are there because they are providing <strong>new information</strong></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-54" style="background:;">
  <hgroup>
    <h2>No Anomalies: Redundancy</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li><p>E.g., consider <code>Student(name, major, address, college)</code> with FDs</p>

<ul>
<li><code>name</code> is a key</li>
<li><code>major</code> \(\rightarrow\) <code>college</code>
<br><br></li>
</ul></li>
<li><p>We decompose it into</p>

<ul>
<li><code>Student1(major, college)</code></li>
<li><code>Student2(name, major, address)</code>
<br><br></li>
</ul></li>
<li><p>There may be duplicate entries in <code>address</code></p></li>
<li><p>But these are not <strong>redundant</strong> entries</p></li>
<li><p>They simply indicate more than one student living in the same place</p></li>
<li><p>The same goes for duplicate entries in the <code>major</code> column</p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-55" style="background:;">
  <hgroup>
    <h2>No Anomalies: Update</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Because there are no redundancies, it is impossible to update a value in one place but forget to do so in some other place
<br><br></li>
<li>The only exception to this is in <strong>keys</strong></li>
<li>If you have up update a key, you must update it in every place it appears
<br><br></li>
<li>This is yet one more reason why <strong>synthetic keys are best</strong></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-56" style="background:;">
  <hgroup>
    <h2>No Anomalies: Deletion</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>If you delete a tuple, may you lose more information than necessary?
<br><br></li>
<li>Well, this can still happen
<br><br></li>
<li>Suppose you want to delete Carrie Fisher&#39;s phone number</li>
<li>Doing so may also delete her address, etc.
<br><br></li>
<li>I.e., if \(R(A,B,C)\) and \(A \rightarrow B, C\), if you delete the row because the value of \(C\) is wrong, you are losing the
information about \(B\)</li>
<li>The answer, of course, is to write a NULL into the \(C\) column, instead of deleting the entire row</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-57" style="background:;">
  <hgroup>
    <h2>Recoverability</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>How do we get \(R\) back from the \(R_i\)
<br><br></li>
<li>The answer is to consider \(R_1 \bowtie R_2 \bowtie \dots \bowtie R_n\)
<br><br></li>
<li>That looks plausible, but there are two questions

<ul>
<li>If a tuple is in \(R\), is it also in \(R_1 \bowtie R_2 \bowtie \dots \bowtie R_n\)?</li>
<li>If a tuple is in \(R_1 \bowtie R_2 \bowtie \dots \bowtie R_n\), is it also in \(R\)?</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-58" style="background:;">
  <hgroup>
    <h2>Recoverability</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we start with \(R(A,B,C)\) and the FD \(B \rightarrow C\)</li>
<li>Then we split \(R\) into

<ul>
<li>\(R(A, B)\)</li>
<li>\(R(B, C)\)</li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>Now suppose \((a, b, c) \in R\)</li>
<li>This means that \((a, b) \in R_1\) and \((b, c) \in R_2\)</li>
<li><p>But then, this also means that \((a, b, c) \in R_1 \bowtie R_2\)</p></li>
<li><p>In general, any tuple in \(R\) is also in \(R_1 \bowtie R_2 \bowtie \dots \bowtie R_n\)</p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-59" style="background:;">
  <hgroup>
    <h2>Recoverability</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we start with \(R(A,B,C)\) and the FD \(B \rightarrow C\)</li>
<li>Then we split \(R\) into

<ul>
<li>\(R(A, B)\)</li>
<li>\(R(B, C)\)</li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>Now suppose \((a, b, c) \in R\) and \((d, b, e) \in R\)</li>
<li>This means that \((a, b)\) and \((d, b)\) are in \(R_1\), and \((b, c)\) and \((b, e)\) are in \(R_2\)</li>
<li>But then, this also means that all of these are in \(R_1 \bowtie R_2\):

<ul>
<li>\((a, b, c)\)</li>
<li>\((d, b, e)\)</li>
<li>\((a, b, e)\)</li>
<li>\((d, b, c)\)</li>
</ul></li>
<li>Are all of these in \(R\)?</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-60" style="background:;">
  <hgroup>
    <h2>Recoverability</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Are all of these in \(R\)?

<ul>
<li>\((a, b, c)\)</li>
<li>\((d, b, e)\)</li>
<li>\((a, b, e)\)</li>
<li>\((d, b, c)\)</li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>The answer is yes!</li>
<li>Since \(B \rightarrow C\), it must be that \(c = e\)</li>
<li>So there are only two tuples, not four:

<ul>
<li>\((a, b, c)\), which is the same as \((a, b, e)\)</li>
<li>\((d, b, e)\), which is the same as \((d, b, c)\)</li>
</ul></li>
<li><p>So all tuples are in \(R\)</p></li>
<li><p>In general, any tuple in \(R_1 \bowtie R_2 \bowtie \dots \bowtie R_n\) is also in \(R\)</p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-61" style="background:;">
  <hgroup>
    <h2>Recoverability</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li><p>The FD \(B \rightarrow C\) is crucial</p></li>
<li><p>Consider the following table, which does not have this FD</p></li>
</ul>

<table><thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
</tbody></table>

<p><br></p>

<ul>
<li>It&#39;s decomposed as follows</li>
</ul>

<div style='float:left;width:48%;'>
  <table><thead>
<tr>
<th>A</th>
<th>B</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>7</td>
</tr>
</tbody></table>

</div>
<div style='float:right;width:48%;'>
  <table><thead>
<tr>
<th>B</th>
<th>C</th>
</tr>
</thead><tbody>
<tr>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
</tr>
<tr>
<td>7</td>
<td>8</td>
</tr>
</tbody></table>

</div>
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-62" style="background:;">
  <hgroup>
    <h2>Lossless Joins</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Recoverability is also called a <strong>lossless join</strong>
<br><br></li>
<li>This means that when we decompose, the join does not <strong>lose information</strong>
<br><br></li>
<li>There is never any danger that we lose some tuple \(t\) that was in the original relation \(R\)</li>
<li>The real danger is that we get some extra tuples in the join that were not in the original relation \(R\) 
<br><br></li>
<li>I.e., without <strong>lossless join</strong>, we get extra tuples</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-63" style="background:;">
  <hgroup>
    <h2>The Chase Test for Lossless Joins</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have a relation \(R\) and a set of dependencies \(S\)</li>
<li>We decompose \(R\) into \(R_1, R_2, \dots, R_n\)</li>
<li>Is this decomposition lossless?
<br><br></li>
<li>One way to answer this question is with the <strong>chase test</strong></li>
<li>The idea is to use the FDs in S to show that any join of the \(R_i\) must result in a tuple originally in \(R\)</li>
<li>We do this by considering a tuple in the join and looking at the tuples in \(R\) that must have generated the
corresponding tuples in the \(R_i\)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-64" style="background:;">
  <hgroup>
    <h2>The Chase Test for Lossless Joins</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Consider \(R(A,B,C,D)\)</li>
<li>Suppose it&#39;s decomposed into \(R_1(A,D)\), \(R_2(A,C)\), and \(R_3(B, C, D)\)
<br><br></li>
<li>Let \((a,b,c,d) \in R\)</li>
<li>Then \((a,d) \in R_1\), \((a,c) \in R_2\) and \((b,c,d) \in R_3\)</li>
<li>So \((a,b,c,d) \in R_1 \bowtie R_2 \bowtie R_3\)</li>
<li>Which means \(R \subset R_1 \bowtie R_2 \bowtie R_3\)
<br><br></li>
<li>That&#39;s the easy direction</li>
<li>The hard part is going the other way</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-65" style="background:;">
  <hgroup>
    <h2>The Chase Test for Lossless Joins</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Consider \(R(A,B,C,D)\)</li>
<li>Suppose it&#39;s decomposed into \(R_1(A,D)\), \(R_2(A,C)\), and \(R_3(B, C, D)\)
<br><br></li>
<li>Let \((a,b,c,d) \in R_1 \bowtie R_2 \bowtie R_3\)</li>
<li>Then there must be tuples \(t_1\), \(t_2\), and \(t_3\) in \(R\) that look like the following</li>
</ul>

<table><thead>
<tr>
<th>\(t_i \in R\)</th>
<th>\(A\)</th>
<th>\(B\)</th>
<th>\(C\)</th>
<th>\(D\)</th>
</tr>
</thead><tbody>
<tr>
<td>\(t_1\)</td>
<td>\(a\)</td>
<td>\(b_1\)</td>
<td>\(c_1\)</td>
<td>\(d\)</td>
</tr>
<tr>
<td>\(t_2\)</td>
<td>\(a\)</td>
<td>\(b_2\)</td>
<td>\(c\)</td>
<td>\(d_2\)</td>
</tr>
<tr>
<td>\(t_3\)</td>
<td>\(a_3\)</td>
<td>\(b\)</td>
<td>\(c\)</td>
<td>\(d\)</td>
</tr>
</tbody></table>

<p><br></p>

<ul>
<li>This is called a <strong>tableau</strong>, not a table (for obvious reasons)</li>
<li>Our goal is to show that one of the \(t_i\) is actually \((a,b,c,d)\)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-66" style="background:;">
  <hgroup>
    <h2>The Chase Test for Lossless Joins</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Next, we use the FDs to &quot;chase&quot; the symbols in the tableau</li>
<li>The goal is to to see which symbols must be the same, e.g., \(b_1 = b_2 = b\)
<br><br></li>
<li>So suppose that the FDs are \(A \rightarrow B\), \(B \rightarrow C\) and \(C, D \rightarrow A\)
<br><br></li>
</ul>

<table><thead>
<tr>
<th>\(t_i \in R\)</th>
<th>\(A\)</th>
<th>\(B\)</th>
<th>\(C\)</th>
<th>\(D\)</th>
</tr>
</thead><tbody>
<tr>
<td>\(t_1\)</td>
<td>\(a\)</td>
<td>\(b_1\)</td>
<td>\(c_1\)</td>
<td>\(d\)</td>
</tr>
<tr>
<td>\(t_2\)</td>
<td>\(a\)</td>
<td>\(b_2\)</td>
<td>\(c\)</td>
<td>\(d_2\)</td>
</tr>
<tr>
<td>\(t_3\)</td>
<td>\(a_3\)</td>
<td>\(b\)</td>
<td>\(c\)</td>
<td>\(d\)</td>
</tr>
</tbody></table>

<p><br></p>

<ul>
<li>Ah! Since \(A \rightarrow B\), \(b_1 = b_2\)</li>
<li>We&#39;ll rename and <strong>keep the lowest subscript</strong></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-67" style="background:;">
  <hgroup>
    <h2>The Chase Test for Lossless Joins</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The FDs are \(A \rightarrow B\), \(B \rightarrow C\) and \(C, D \rightarrow A\)
<br><br></li>
</ul>

<table><thead>
<tr>
<th>\(t_i \in R\)</th>
<th>\(A\)</th>
<th>\(B\)</th>
<th>\(C\)</th>
<th>\(D\)</th>
</tr>
</thead><tbody>
<tr>
<td>\(t_1\)</td>
<td>\(a\)</td>
<td>\(b_1\)</td>
<td>\(c_1\)</td>
<td>\(d\)</td>
</tr>
<tr>
<td>\(t_2\)</td>
<td>\(a\)</td>
<td>\(b_1\)</td>
<td>\(c\)</td>
<td>\(d_2\)</td>
</tr>
<tr>
<td>\(t_3\)</td>
<td>\(a_3\)</td>
<td>\(b\)</td>
<td>\(c\)</td>
<td>\(d\)</td>
</tr>
</tbody></table>

<p><br></p>

<ul>
<li>Ah! Since \(B \rightarrow C\), \(c_1 = c\)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-68" style="background:;">
  <hgroup>
    <h2>The Chase Test for Lossless Joins</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The FDs are \(A \rightarrow B\), \(B \rightarrow C\) and \(C, D \rightarrow A\)
<br><br></li>
</ul>

<table><thead>
<tr>
<th>\(t_i \in R\)</th>
<th>\(A\)</th>
<th>\(B\)</th>
<th>\(C\)</th>
<th>\(D\)</th>
</tr>
</thead><tbody>
<tr>
<td>\(t_1\)</td>
<td>\(a\)</td>
<td>\(b_1\)</td>
<td>\(c\)</td>
<td>\(d\)</td>
</tr>
<tr>
<td>\(t_2\)</td>
<td>\(a\)</td>
<td>\(b_1\)</td>
<td>\(c\)</td>
<td>\(d_2\)</td>
</tr>
<tr>
<td>\(t_3\)</td>
<td>\(a_3\)</td>
<td>\(b\)</td>
<td>\(c\)</td>
<td>\(d\)</td>
</tr>
</tbody></table>

<p><br></p>

<ul>
<li>And since \(C, D \rightarrow A\), \(a_3 = a\)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-69" style="background:;">
  <hgroup>
    <h2>The Chase Test for Lossless Joins</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The FDs are \(A \rightarrow B\), \(B \rightarrow C\) and \(C, D \rightarrow A\)
<br><br></li>
</ul>

<table><thead>
<tr>
<th>\(t_i \in R\)</th>
<th>\(A\)</th>
<th>\(B\)</th>
<th>\(C\)</th>
<th>\(D\)</th>
</tr>
</thead><tbody>
<tr>
<td>\(t_1\)</td>
<td>\(a\)</td>
<td>\(b_1\)</td>
<td>\(c\)</td>
<td>\(d\)</td>
</tr>
<tr>
<td>\(t_2\)</td>
<td>\(a\)</td>
<td>\(b_1\)</td>
<td>\(c\)</td>
<td>\(d_2\)</td>
</tr>
<tr>
<td>\(t_3\)</td>
<td>\(a\)</td>
<td>\(b\)</td>
<td>\(c\)</td>
<td>\(d\)</td>
</tr>
</tbody></table>

<p><br></p>

<ul>
<li>Back to \(A \rightarrow B\), \(b_1 = b\)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-70" style="background:;">
  <hgroup>
    <h2>The Chase Test for Lossless Joins</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The FDs are \(A \rightarrow B\), \(B \rightarrow C\) and \(C, D \rightarrow A\)
<br><br></li>
</ul>

<table><thead>
<tr>
<th>\(t_i \in R\)</th>
<th>\(A\)</th>
<th>\(B\)</th>
<th>\(C\)</th>
<th>\(D\)</th>
</tr>
</thead><tbody>
<tr>
<td>\(t_1\)</td>
<td>\(a\)</td>
<td>\(b\)</td>
<td>\(c\)</td>
<td>\(d\)</td>
</tr>
<tr>
<td>\(t_2\)</td>
<td>\(a\)</td>
<td>\(b\)</td>
<td>\(c\)</td>
<td>\(d_2\)</td>
</tr>
<tr>
<td>\(t_3\)</td>
<td>\(a\)</td>
<td>\(b\)</td>
<td>\(c\)</td>
<td>\(d\)</td>
</tr>
</tbody></table>

<p><br></p>

<ul>
<li>We can get rid of one of the duplicate rows</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-71" style="background:;">
  <hgroup>
    <h2>The Chase Test for Lossless Joins</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The FDs are \(A \rightarrow B\), \(B \rightarrow C\) and \(C, D \rightarrow A\)
<br><br></li>
</ul>

<table><thead>
<tr>
<th>\(t_i \in R\)</th>
<th>\(A\)</th>
<th>\(B\)</th>
<th>\(C\)</th>
<th>\(D\)</th>
</tr>
</thead><tbody>
<tr>
<td>\(t_1\)</td>
<td>\(a\)</td>
<td>\(b\)</td>
<td>\(c\)</td>
<td>\(d\)</td>
</tr>
<tr>
<td>\(t_2\)</td>
<td>\(a\)</td>
<td>\(b\)</td>
<td>\(c\)</td>
<td>\(d_2\)</td>
</tr>
</tbody></table>

<p><br></p>

<ul>
<li>And now we&#39;re done</li>
<li>Notice that \(t_1\) is exactly \((a,b,c,d)\)</li>
<li>We started with a tuple in \(R_1 \bowtie R_2 \bowtie R_3\) and showed that it must also be in \(R\)</li>
<li>So \(R_1 \bowtie R_2 \bowtie R_3 \subset R\)</li>
<li>And therefore \(R_1 \bowtie R_2 \bowtie R_3 = R\)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-72" style="background:;">
  <hgroup>
    <h2>Example of Decomposition into BCNF</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have \(R(A, B, C, D)\) with FDs

<ul>
<li>\(A, B \rightarrow C\)</li>
<li>\(B \rightarrow D\)</li>
<li>\(C \rightarrow A\)</li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>The first step is to find the keys</li>
<li>We do this by considering closures, and in particular \(\{A,B\}^+ = \{B,C\}^+ = \{A, B, C, D\}\)</li>
<li>Adding \(D\) to either \(\{A,B\}\) or \(\{B,C\}\) wouldn&#39;t help</li>
<li>And removing any attribute from either \(\{A,B\}\) or \(\{B,C\}\) would narrow the closure</li>
<li>So both \(\{A,B\}\) and \(\{B,C\}\) are keys</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-73" style="background:;">
  <hgroup>
    <h2>Example of Decomposition into BCNF</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have \(R(A, B, C, D)\) with FDs

<ul>
<li>\(A, B \rightarrow C\)</li>
<li>\(B \rightarrow D\)</li>
<li>\(C \rightarrow A\)</li>
<li>Keys: \(\{A,B\}\) and \(\{B,C\}\)</li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>The second step is to consider each of the FDs until we find a violation of BCNF</li>
<li>\(A, B \rightarrow C\) is not a violation of BCNF, because \(\{A,B\}\) is a key</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-74" style="background:;">
  <hgroup>
    <h2>Example of Decomposition into BCNF</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have \(R(A, B, C, D)\) with FDs

<ul>
<li>\(A, B \rightarrow C\)</li>
<li>\(B \rightarrow D\)</li>
<li>\(C \rightarrow A\)</li>
<li>Keys: \(\{A,B\}\) and \(\{B,C\}\)</li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>The second step is to consider each of the FDs until we find a violation of BCNF</li>
<li>But \(B \rightarrow D\) is a violation of BCNF, because \(\{B\}\) is not a superkey</li>
<li>So we split \(R\) into

<ul>
<li>\(R_1(B, D)\)</li>
<li>\(R_2(B, A, C)\)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-75" style="background:;">
  <hgroup>
    <h2>Example of Decomposition into BCNF</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have \(R(A, B, C, D)\) with FDs

<ul>
<li>\(A, B \rightarrow C\)</li>
<li>\(B \rightarrow D\)</li>
<li>\(C \rightarrow A\)</li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>The third step is to recurvisely turn each of the \(R_i\) into BCNF</li>
<li>\(R_1(B, D)\) is already in BCNF, since it only has two attributes</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-76" style="background:;">
  <hgroup>
    <h2>Example of Decomposition into BCNF</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have \(R(A, B, C, D)\) with FDs

<ul>
<li>\(A, B \rightarrow C\)</li>
<li>\(B \rightarrow D\)</li>
<li>\(C \rightarrow A\)</li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>The third step is to recurvisely turn each of the \(R_i\) into BCNF</li>
<li>For \(R_2(B, A, C)\), we have to go back to the drawing board</li>
<li>What are the FDs for \(R_2\)?</li>
<li>We need to project the FDs above to \(R_2\)</li>
<li>In this case, we can just omit the second FD (but in general, you have to consider all possible left-hand sides for FDs)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-77" style="background:;">
  <hgroup>
    <h2>Example of Decomposition into BCNF</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li><p>Suppose we have \(R(A, B, C, D)\) with FDs</p>

<ul>
<li>\(A, B \rightarrow C\)</li>
<li>\(B \rightarrow D\)</li>
<li>\(C \rightarrow A\)</li>
</ul></li>
<li><p>We project the FDs for \(R_2(B, A, C)\)</p></li>
</ul>

<table><thead>
<tr>
<th>Left-hand side \(X\)</th>
<th>\(X^+ \cap \{B, A, C\}\)</th>
<th>FD</th>
</tr>
</thead><tbody>
<tr>
<td>\(A\)</td>
<td>\(A\)</td>
<td></td>
</tr>
<tr>
<td>\(B\)</td>
<td>\(B\)</td>
<td></td>
</tr>
<tr>
<td>\(C\)</td>
<td>\(C, A\)</td>
<td>\(C \rightarrow C, A\)</td>
</tr>
<tr>
<td>\(A, B\)</td>
<td>\(A, B, C\)</td>
<td>\(A, B \rightarrow C\)</td>
</tr>
<tr>
<td>\(A, C\)</td>
<td>\(A, C\)</td>
<td></td>
</tr>
<tr>
<td>\(B, C\)</td>
<td>\(B, C, A\)</td>
<td>\(B, C \rightarrow A\)</td>
</tr>
</tbody></table>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-78" style="background:;">
  <hgroup>
    <h2>Example of Decomposition into BCNF</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li><p>We project the FDs to \(R_2(B, A, C)\)</p>

<ul>
<li>\(A, B \rightarrow C\)</li>
<li>\(B \rightarrow D\)</li>
<li>\(C \rightarrow A\)</li>
</ul></li>
<li><p>So \(R_2\) has these functional dependencies:</p>

<ul>
<li>\(C \rightarrow C, A\)</li>
<li>\(A, B \rightarrow C\)</li>
<li>\(B, C \rightarrow A\)</li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>Of course, we want a minimal basis for those, e.g.:

<ul>
<li>\(C \rightarrow A\)</li>
<li>\(A, B \rightarrow C\)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-79" style="background:;">
  <hgroup>
    <h2>Example of Decomposition into BCNF</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have \(R_2(B, A, C)\) with FDs

<ul>
<li>\(C \rightarrow A\)</li>
<li>\(A, B \rightarrow C\)</li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>The first step is to find the keys</li>
<li>Notice we need \(B\) in any key (since it doesn&#39;t appear in the right-hand side)</li>
<li>Then we find that \(\{A,B\}^+ = \{B,C\}^+ = \{A, B, C\}\)</li>
<li>But \(B\) by itself isn&#39;t enough, because \(B^+ = \{B\}\)</li>
<li>So both \(\{A,B\}\) and \(\{B,C\}\) are keys</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-80" style="background:;">
  <hgroup>
    <h2>Example of Decomposition into BCNF</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have \(R_2(B, A, C)\) with FDs

<ul>
<li>\(C \rightarrow A\)</li>
<li>\(A, B \rightarrow C\)</li>
<li>Keys: \(\{A,B\}\) and \(\{B,C\}\)</li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>The second step is to consider each of the FDs until we find a violation of BCNF</li>
<li>Rightaway \(C \rightarrow A\) is a violation of BCNF, because \(\{C\}\) is not a superkey</li>
<li>So we split \(R_2\) into

<ul>
<li>\(R_{2,1}(C, A)\)</li>
<li>\(R_{2,2}(C, B)\)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-81" style="background:;">
  <hgroup>
    <h2>Example of Decomposition into BCNF</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have \(R_2(B, A, C)\) with FDs

<ul>
<li>\(C \rightarrow A\)</li>
<li>\(A, B \rightarrow C\)</li>
<li>Keys: \(\{A,B\}\) and \(\{B,C\}\)</li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>Ordinarily, we would move on to the third step, which is to recursively decompose \(R_{2,1}(C,A)\) and \(R_{2,2}(C,B)\)</li>
<li><p>But both of those relations have only two attributes, so we know they are already in BCNF</p></li>
<li><p>So the final decomposition of \(R(A,B,C,D)\) is</p>

<ul>
<li>\(R_1(B, D)\)</li>
<li>\(R_{2,1}(C, A)\)</li>
<li>\(R_{2,2}(C, B)\)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-82" style="background:;">
  <hgroup>
    <h2>Example of Decomposition into BCNF</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have \(R_2(B, A, C)\) with FDs

<ul>
<li>\(C \rightarrow A\)</li>
<li>\(A, B \rightarrow C\)</li>
<li>Keys: \(\{A,B\}\) and \(\{B,C\}\)</li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>Ordinarily, we would move on to the third step, which is to recursively decompose \(R_{2,1}(C,A)\) and \(R_{2,2}(C,B)\)</li>
<li><p>But both of those relations have only two attributes, so we know they are already in BCNF</p></li>
<li><p>So the final decomposition of \(R(A,B,C,D)\) is</p>

<ul>
<li>\(R_1(B, D)\)</li>
<li>\(R_{2,1}(C, A)\)</li>
<li>\(R_{2,2}(C, B)\)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-83" style="background:;">
  <hgroup>
    <h2>Example of Decomposition into BCNF (Important Aside)</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li><p>We started with the relation \(R(A, B, C, D)\) with FDs</p>

<ul>
<li>\(A, B \rightarrow C\)</li>
<li>\(B \rightarrow D\)</li>
<li>\(C \rightarrow A\)</li>
</ul></li>
<li><p>We decomposed it into</p>

<ul>
<li>\(R_1(B, D)\)</li>
<li>\(R_{2,1}(C, A)\)</li>
<li>\(R_{2,2}(C, B)\)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-84" style="background:;">
  <hgroup>
    <h2>Example of Decomposition into BCNF (Important Aside)</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li><p>We started with the relation \(R(A, B, C, D)\) with FDs</p>

<ul>
<li>\(A, B \rightarrow C\)</li>
<li>\(B \rightarrow D\)</li>
<li>\(C \rightarrow A\)</li>
</ul></li>
<li><p>We did <em>not</em> decompose \(R\) into</p>

<ul>
<li>\(R_1(A, B, C)\)</li>
<li>\(R_2(B, D)\)</li>
<li>\(R_3(C, A)\)</li>
</ul></li>
<li><p>Don&#39;t make that mistake! (A lot of students do)</p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-85" style="background:;">
  <hgroup>
    <h2>Dependency Preservation</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li><p>We started with the relation \(R(A, B, C, D)\) with FDs</p>

<ul>
<li>\(A, B \rightarrow C\)</li>
<li>\(B \rightarrow D\)</li>
<li>\(C \rightarrow A\)</li>
</ul></li>
<li><p>We decomposed it into</p>

<ul>
<li>\(R_1(B, D)\)</li>
<li>\(R_{2,1}(C, A)\)</li>
<li>\(R_{2,2}(C, B)\)</li>
</ul></li>
<li><p>What happened to the FD</p>

<ul>
<li>\(A, B \rightarrow C\)?</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-86" style="background:;">
  <hgroup>
    <h1>Third Normal Form (3NF)</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-87" style="background:;">
  <hgroup>
    <h2>Third Normal Form (3NF)</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>In practice, decomposition into BCNF is

<ul>
<li>free of redundancy anomalies</li>
<li>mostly free of other anomalies</li>
<li>guaranteed lossless</li>
<li>usually dependency-preserving
<br><br></li>
</ul></li>
<li>But what about those few times when it is not dependency-preserving
<br><br></li>
<li>A solution is to decompose into a weaker normal form, called <strong>Third Normal Form</strong> or <strong>3NF</strong>
<br><br></li>
<li>Note: 3NF came first, so interview questions are often about 3NF</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-88" style="background:;">
  <hgroup>
    <h2>Third Normal Form (3NF)</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>A relation \(R\) is in third normal form if for every non-trivial FD \(A_1, A_2, \dots, A_n \rightarrow B_1, B_2, \dots B_m\)

<ul>
<li>Either \(\{A_1, A_2, \dots, A_n\}\) is a <strong>superkey</strong></li>
<li>Or each of the \(B_i\) is equal to one of the \(A_j\) or is part of a <strong>key</strong> (not necessarily the same key)
<br><br></li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>Notice that the first condition is equivalent to BCNF</li>
<li>So any relation in \(BCNF\) is automatically in \(3NF\)</li>
<li>But there are \(3NF\) relations that are not in \(BCNF\)</li>
<li>That&#39;s what we mean when we say 3NF is a weaker normal form than BCNF</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-89" style="background:;">
  <hgroup>
    <h2>Third Normal Form Guarantees</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We will now show how to decompose a relation into 3NF
<br><br></li>
<li>In practice, decomposition into 3NF is

<ul>
<li>not necessarily free of redundancy anomalies</li>
<li>mostly free of other anomalies</li>
<li>guaranteed lossless</li>
<li>guaranteed dependency-preserving</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-90" style="background:;">
  <hgroup>
    <h2>Decomposition into 3NF</h2>
  </hgroup>
  <article data-timings="">
    <p>INPUT: A relation \(R\) with attributes \(\mathcal{A}\) and a set of FDs \(S\)</p>

<p>OUTPUT: A decomposition of \(R\) into relations \(R_1, R_2, \dots, R_n\), all of which are in 3NF</p>

<ol>
<li>Let \(G\) be a minimal basis for the FDs \(S\)</li>
<li>For each \(X \rightarrow A\) in \(G\), create a relation with attributes \(X, A\)</li>
<li>If the attributes in one of the resulting relations is a superkey for \(R\), we&#39;re done</li>
<li>Otherwise, add an extra relation whose schema is a key for \(R\)</li>
</ol>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-91" style="background:;">
  <hgroup>
    <h2>Example Decomposition into 3NF</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Recall \(R(A, B, C, D)\) with FDs

<ul>
<li>\(A, B \rightarrow C\)</li>
<li>\(B \rightarrow D\)</li>
<li>\(C \rightarrow A\)</li>
</ul></li>
<li>Remember that we failed to decompose it into BCNF in a way that was dependency preserving
<br><br></li>
<li>Now we&#39;ll decompose it into 3NF instead</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-92" style="background:;">
  <hgroup>
    <h2>Example Decomposition into 3NF: Step 1</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We have these FDs

<ul>
<li>\(A, B \rightarrow C\)</li>
<li>\(B \rightarrow D\)</li>
<li>\(C \rightarrow A\)
<br><br></li>
</ul></li>
<li>No FD follows from the others, so we cannot remove any of the FDs without changing the constraints
<br><br></li>
<li>The only FD with more than one attribute in the left-hand side is \(A, B \rightarrow C\), but removing
either \(A\) or \(B\) changes the constraints
<br><br></li>
<li>We conclude that this set of FDs is already a minimal basis</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-93" style="background:;">
  <hgroup>
    <h2>Example Decomposition into 3NF: Step 2</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We have these FDs

<ul>
<li>\(A, B \rightarrow C\)</li>
<li>\(B \rightarrow D\)</li>
<li>\(C \rightarrow A\)
<br><br></li>
</ul></li>
<li>So we decompose the relation \(R\) into

<ul>
<li>\(R_1(A, B, C)\)</li>
<li>\(R_2(B, D)\)</li>
<li>\(R_3(C, A)\)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-94" style="background:;">
  <hgroup>
    <h2>Example Decomposition into 3NF: Step 3</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We have a relation from each FD:</li>
</ul>

<table><thead>
<tr>
<th>FD</th>
<th>Table</th>
</tr>
</thead><tbody>
<tr>
<td>\(A, B \rightarrow C\)</td>
<td>\(R_1(A, B, C)\)</td>
</tr>
<tr>
<td>\(B \rightarrow D\)</td>
<td>\(R_2(B, D)\)</td>
</tr>
<tr>
<td>\(C \rightarrow A\)</td>
<td>\(R_3(C, A)\)</td>
</tr>
</tbody></table>

<p><br></p>

<ul>
<li>Are we done?</li>
<li>We have to consider all the keys of \(R\):

<ul>
<li>\(A, B\)</li>
<li>\(B, C\)</li>
</ul></li>
<li>That means the attributes of \(R_1\) are a superkey for \(R\), so we&#39;re done</li>
<li>Otherwise, we could have picked any of the key candidates and turned it into \(R_4\)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-95" style="background:;">
  <hgroup>
    <h2>Why the Decomposition into 3NF Works</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Clearly, all FDs are preserved

<ul>
<li>Each FD becomes one of the \(R_i\), so no FD can be lost
<br><br></li>
</ul></li>
<li>The decomposition is lossless

<ul>
<li>Start with a tuple \(t \in R_1 \bowtie R_2 \bowtie \dots R_k\)</li>
<li>One of the \(R_i\) contains a key for \(R\)</li>
<li>Let \(t_i\) be the projection of \(t\) onto \(R_i\)</li>
<li>Now that we know the tuple \(t_i \in R_i\), all the other attributes are determined</li>
<li>So only one tuple from each of the other \(R_j\) will join with that \(t_i\)</li>
<li>I.e., no &quot;extra&quot; tuples can sneak in the join</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-96" style="background:;">
  <hgroup>
    <h2>Multivalued Dependencies</h2>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-97" style="background:;">
  <hgroup>
    <h2>Multivalued Dependencies</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Consider the following table</li>
</ul>

<table><thead>
<tr>
<th>Name</th>
<th>Street</th>
<th>City</th>
<th>Title</th>
<th>Year</th>
</tr>
</thead><tbody>
<tr>
<td>Carrie Fisher</td>
<td>123 Maple St.</td>
<td>Hollywood</td>
<td>Star Wars</td>
<td>1977</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>5 Locust Ln.</td>
<td>Malibu</td>
<td>Star Wars</td>
<td>1977</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>123 Maple St.</td>
<td>Hollywood</td>
<td>Empire Strikes Back</td>
<td>1980</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>5 Locust Ln.</td>
<td>Malibu</td>
<td>Empire Strikes Back</td>
<td>1980</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>123 Maple St.</td>
<td>Hollywood</td>
<td>Return of the Jedi</td>
<td>1983</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>5 Locust Ln.</td>
<td>Malibu</td>
<td>Return of the Jedi</td>
<td>1983</td>
</tr>
</tbody></table>

<ul>
<li>Obviously there are many redundancies</li>
<li>But there is no BCNF violation!</li>
<li>The reason is that there are no non-trivial dependencies</li>
<li>There are three different real-world entity types here: actors, addresses, and movies</li>
<li>But none of them functionally determine any of the others</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-98" style="background:;">
  <hgroup>
    <h2>Multivalued Dependencies</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>So what&#39;s wrong with this table?</li>
</ul>

<table><thead>
<tr>
<th>Name</th>
<th>Street</th>
<th>City</th>
<th>Title</th>
<th>Year</th>
</tr>
</thead><tbody>
<tr>
<td>Carrie Fisher</td>
<td>123 Maple St.</td>
<td>Hollywood</td>
<td>Star Wars</td>
<td>1977</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>5 Locust Ln.</td>
<td>Malibu</td>
<td>Star Wars</td>
<td>1977</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>123 Maple St.</td>
<td>Hollywood</td>
<td>Empire Strikes Back</td>
<td>1980</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>5 Locust Ln.</td>
<td>Malibu</td>
<td>Empire Strikes Back</td>
<td>1980</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>123 Maple St.</td>
<td>Hollywood</td>
<td>Return of the Jedi</td>
<td>1983</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>5 Locust Ln.</td>
<td>Malibu</td>
<td>Return of the Jedi</td>
<td>1983</td>
</tr>
</tbody></table>

<ul>
<li>There are no BCNF violations</li>
<li>But the street/city entries are totally independent from the title/year entries</li>
<li>So the table must contain the cross product of street/city and title/year</li>
<li>To address this problem, we must capture that street/city <strong>is independent of</strong> title/year</li>
<li>This is called a <strong>multivalued dependency (MVD)</strong></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-99" style="background:;">
  <hgroup>
    <h2>Multivalued Dependencies</h2>
  </hgroup>
  <article data-timings="">
    <table><thead>
<tr>
<th>Name</th>
<th>Street</th>
<th>City</th>
<th>Title</th>
<th>Year</th>
</tr>
</thead><tbody>
<tr>
<td>Carrie Fisher</td>
<td>123 Maple St.</td>
<td>Hollywood</td>
<td>Star Wars</td>
<td>1977</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>5 Locust Ln.</td>
<td>Malibu</td>
<td>Star Wars</td>
<td>1977</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>123 Maple St.</td>
<td>Hollywood</td>
<td>Empire Strikes Back</td>
<td>1980</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>5 Locust Ln.</td>
<td>Malibu</td>
<td>Empire Strikes Back</td>
<td>1980</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>123 Maple St.</td>
<td>Hollywood</td>
<td>Return of the Jedi</td>
<td>1983</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>5 Locust Ln.</td>
<td>Malibu</td>
<td>Return of the Jedi</td>
<td>1983</td>
</tr>
</tbody></table>

<ul>
<li>The MVD for this table is \(\text{name} \twoheadrightarrow \text{street}, \text{city}\)
<br><br></li>
<li>Suppose there are two tuples \(t\) and \(u\) that agree on name</li>
<li>Then there must be another tuple \(v\) that

<ol>
<li>agrees with \(t\) and \(u\) on name</li>
<li>agrees with \(t\) on street and city</li>
<li>agrees with \(u\) on title and year</li>
</ol></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-100" style="background:;">
  <hgroup>
    <h2>Multivalued Dependencies</h2>
  </hgroup>
  <article data-timings="">
    <table><thead>
<tr>
<th>Name</th>
<th>Street</th>
<th>City</th>
<th>Title</th>
<th>Year</th>
</tr>
</thead><tbody>
<tr>
<td>Carrie Fisher</td>
<td>123 Maple St.</td>
<td>Hollywood</td>
<td>Star Wars</td>
<td>1977</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>5 Locust Ln.</td>
<td>Malibu</td>
<td>Star Wars</td>
<td>1977</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>123 Maple St.</td>
<td>Hollywood</td>
<td>Empire Strikes Back</td>
<td>1980</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>5 Locust Ln.</td>
<td>Malibu</td>
<td>Empire Strikes Back</td>
<td>1980</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>123 Maple St.</td>
<td>Hollywood</td>
<td>Return of the Jedi</td>
<td>1983</td>
</tr>
<tr>
<td>Carrie Fisher</td>
<td>5 Locust Ln.</td>
<td>Malibu</td>
<td>Return of the Jedi</td>
<td>1983</td>
</tr>
</tbody></table>

<ul>
<li>Consider \(\text{name} \twoheadrightarrow \text{street}, \text{city}\)

<ul>
<li>\(t = (\text{Carrie Fisher}, \text{123 Maple St.}, \text{Hollywood}, \text{Star Wars}, 1977)\)</li>
<li>\(u = (\text{Carrie Fisher}, \text{5 Locust Ln.}, \text{Malibu}, \text{Empire Strikes Back}, 1980)\)
<br><br></li>
<li>\(v = (\text{Carrie Fisher}, \text{123 Maple St.}, \text{Hollywood}, \text{Empire Strikes Back}, 1980)\)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-101" style="background:;">
  <hgroup>
    <h2>Multivalued Dependencies</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>In general, suppose we have a relation \(R\) with attributes \(\mathcal{A}\)</li>
<li>An MVD \(X \twoheadrightarrow Y\) holds if whenever we find two tuples \(t\) and \(u\) that agree on \(X\), we can find
another tuple \(v\) that

<ol>
<li>agrees with \(t\) and \(u\) on \(X\)</li>
<li>agrees with \(t\) on \(Y\)</li>
<li>agrees with \(u\) on \(\mathcal{A}-(X \cup Y)\)</li>
</ol></li>
</ul>

<table><thead>
<tr>
<th>tuple</th>
<th>X</th>
<th>Y</th>
<th>Z</th>
</tr>
</thead><tbody>
<tr>
<td>t</td>
<td>x1</td>
<td>y1</td>
<td>z1</td>
</tr>
<tr>
<td>u</td>
<td>x1</td>
<td>y2</td>
<td>z2</td>
</tr>
<tr>
<td></td>
<td>&nbsp;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>v</td>
<td>x1</td>
<td>y1</td>
<td>z2</td>
</tr>
<tr>
<td>w</td>
<td>x1</td>
<td>y2</td>
<td>z1</td>
</tr>
</tbody></table>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-102" style="background:;">
  <hgroup>
    <h2>Rules for Multivalued Dependencies</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li><strong>Trivial MVDs</strong> 

<ul>
<li>\(A_1, A_2, \dots, A_m \twoheadrightarrow B_1, B_2, \dots, B_n\) holds if
\(\{B_1, B_2, \dots, B_n\} \subset \{A_1, A_2, \dots, A_m\}\)
<br><br></li>
</ul></li>
<li><strong>Transitive Rule</strong>

<ul>
<li>If \(A_1, A_2, \dots, A_m \twoheadrightarrow B_1, B_2, \dots, B_n\) and
\(B_1, B_2, \dots, B_n \twoheadrightarrow C_1, C_2, \dots, C_k\), then
\(A_1, A_2, \dots, A_m \twoheadrightarrow C_1, C_2, \dots, C_k\)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-103" style="background:;">
  <hgroup>
    <h2>Caveat on Rules for Multivalued Dependencies</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The use of an arrow \(\twoheadrightarrow\) is suggestive, but potentially misleading</li>
<li>It makes it very natural to believe that, say, the transitive rule holds
<br><br></li>
<li>The problem is that our intuition can fail us</li>
<li>E.g., the splitting rule does not hold!</li>
<li>\(A \twoheadrightarrow B, C\) does not mean

<ul>
<li>\(A \twoheadrightarrow B\)</li>
<li>\(A \twoheadrightarrow C\)</li>
</ul></li>
<li>The reason is that \(A \twoheadrightarrow B, C\) says something about the columns \(A\), \(B\), \(C\),
but also <strong>all other columns</strong> in the relation</li>
<li>E.g., \(\text{name} \twoheadrightarrow \text{street}, \text{city}\) actually says something about
the relationship between street/city and title/year</li>
<li>But \(\text{name} \twoheadrightarrow \text{street}\) says something about the relationship between
street and city/title/year (which is bogus)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-104" style="background:;">
  <hgroup>
    <h2>More Rules for Multivalued Dependencies</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li><strong>FD Promotion</strong> 

<ul>
<li>If \(X \rightarrow Y\), then \(X \twoheadrightarrow Y\)</li>
<li>To see why, choose \(t\) and \(u\), and then let \(v = u\)
<br><br></li>
</ul></li>
<li><strong>Complementation Rule</strong>

<ul>
<li>If \(X \twoheadrightarrow Y\), then \(X \twoheadrightarrow \mathcal{A} - Y\)</li>
<li>To see why, consider the symmetry in the definition of \(X \twoheadrightarrow Y\)
<br><br></li>
</ul></li>
<li><strong>Trivial MVDs</strong>

<ul>
<li>\(X \twoheadrightarrow \mathcal{A}-X\)</li>
<li>To see why, choose \(t\) and \(u\), and then let \(v = t\)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-105" style="background:;">
  <hgroup>
    <h2>Fourth Normal Form (4NF)</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>A relation \(R\) is in <strong>fourth normal form (4NF)</strong> if 

<ul>
<li>whenever \(A_1, A_2, \dots, A_m \twoheadrightarrow B_1, B_2, \dots, B_n\) is a nontrivial MVD for \(R\),</li>
<li>\(\{A_1, A_2, \dots, A_m\}\) is a superkey for \(R\)
<br><br></li>
</ul></li>
<li>Since all FDs are also MVDs, any relation in 4NF is also in BCNF, so it&#39;s also in 3NF</li>
<li>I.e., \(\text{4NF} \subset \text{BCNF} \subset \text{3NF}\)</li>
</ul>

<ul class = "build incremental">
<li>Good news!</li>
<li>The algorithm for decomposing into BCNF just works for decomposing into 4NF</li>
<li>The only difference is that it decomposes on MVDs that violate 4NF instead of on FDs that violate BCNF</li>
<li>Minor complication: Projecting MVDs is not as easy as projecting FDs</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-106" style="background:;">
  <hgroup>
    <h2>Relationship among Normal Forms</h2>
  </hgroup>
  <article data-timings="">
    <table><thead>
<tr>
<th>Property</th>
<th>3NF</th>
<th>BCNF</th>
<th>4NF</th>
</tr>
</thead><tbody>
<tr>
<td>Eliminates FD redundancies</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Eliminates MVD redundancies</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Preserves FDs</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Preserves MVDs</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
</tbody></table>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-107" style="background:;">
  <hgroup>
    <h1>Algorithms for MVDs</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-108" style="background:;">
  <hgroup>
    <h2>The Closure Algorithm</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Earlier we discussed the <strong>closure algorithm</strong> that computes \(X^+\)</li>
<li>We also discussed the <strong>chase algorithm</strong> for proving lossless decompositions
<br><br></li>
<li>In fact the chase algorithm is very useful in many other contexts</li>
<li>We can restate the closure algorithm as a chase starting from a tableau

<ol>
<li>The tableau starts with two rows that agree on \(X\) and on nothing else</li>
<li>After the chase, \(A \in X^+\) if and only if the rows agree on attribute \(A\)</li>
</ol></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-109" style="background:;">
  <hgroup>
    <h2>The Chase Algorithm for MVDs</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We&#39;ve been using the chase algorithm to find which attributes are equal based on some FD</li>
<li>But an MVD \(X \twoheadrightarrow Y\) does not tell us that some values must be equal</li>
<li>Instead, it tells us that if we have two tuples \(t\) and \(u\), we can construct another tuple
\(v\) with some properties</li>
<li>Actually, by symmetry, we can construct two tuples \(v\) and \(w\) (by swapping \(t\) and \(u\)),
but sometimes the resulting tuples will not be new
<br><br></li>
<li>So we modify the chase algorithm</li>
<li>We start with some tuples</li>
<li>Then we apply MVDs to create more tuples!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-110" style="background:;">
  <hgroup>
    <h2>The Chase Algorithm for Inferring MVDs</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have some FDs and some MVDs</li>
<li>We want to decide if the MVD \(X \twoheadrightarrow Y\) is implied by these FDs and MVDs
<br><br></li>
<li>Start a tableau with two tuples

<ul>
<li>\(t\)</li>
<li>\(u\), which agrees with \(t\) on \(X\) and nothing else</li>
</ul></li>
<li>Repeatedly apply the FDs and MVDs to the tableau</li>
<li>If we ever find a tuple \(v\) that agrees with \(t\) and \(u\) on \(X\), with \(t\) on \(Y\),
and with \(u\) on \(\mathcal{A}-Y\), then the MVD \(X \twoheadrightarrow Y\) is implied</li>
<li>If we terminate without finding such a tuple, then \(X \twoheadrightarrow Y\) is not implied</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-111" style="background:;">
  <hgroup>
    <h2>The Chase Algorithm for Inferring MVDs</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have \(R(A,B,C,D)\) with dependencies

<ul>
<li>\(A \rightarrow B\)</li>
<li>\(B \twoheadrightarrow C\)</li>
</ul></li>
<li><p>Does \(A \twoheadrightarrow C\) hold?
<br><br></p></li>
<li><p>Consider this tableau</p></li>
</ul>

<table><thead>
<tr>
<th>\(A\)</th>
<th>\(B\)</th>
<th>\(C\)</th>
<th>\(D\)</th>
</tr>
</thead><tbody>
<tr>
<td>\(a\)</td>
<td>\(b_1\)</td>
<td>\(c\)</td>
<td>\(d_1\)</td>
</tr>
<tr>
<td>\(a\)</td>
<td>\(b\)</td>
<td>\(c_2\)</td>
<td>\(d\)</td>
</tr>
</tbody></table>

<ul>
<li>Keep doing the chase, and look for the tuple \((a,b,c,d)\)</li>
<li>Notice how we have unsubscripted variables for \(a\) (lhs, shared) and just \(c\) (rhs) on the first tuple,
and \(a\) (lhs) and \(b\) and \(d\) (not in MVD) in second tuple, so it&#39;s easier to check when a complete
unsubscripted tuple shows up.</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-112" style="background:;">
  <hgroup>
    <h2>The Chase Algorithm for Inferring MVDs</h2>
  </hgroup>
  <article data-timings="">
    <table><thead>
<tr>
<th>\(A\)</th>
<th>\(B\)</th>
<th>\(C\)</th>
<th>\(D\)</th>
<th>Dependency</th>
</tr>
</thead><tbody>
<tr>
<td>\(a\)</td>
<td>\(b_1\)</td>
<td>\(c\)</td>
<td>\(d_1\)</td>
<td></td>
</tr>
<tr>
<td>\(a\)</td>
<td>\(b\)</td>
<td>\(c_2\)</td>
<td>\(d\)</td>
<td></td>
</tr>
</tbody></table>

<p><br></p>

<table><thead>
<tr>
<th>\(A\)</th>
<th>\(B\)</th>
<th>\(C\)</th>
<th>\(D\)</th>
<th>Dependency</th>
</tr>
</thead><tbody>
<tr>
<td>\(a\)</td>
<td>\(b\)</td>
<td>\(c\)</td>
<td>\(d_1\)</td>
<td>\(A \rightarrow B\)</td>
</tr>
<tr>
<td>\(a\)</td>
<td>\(b\)</td>
<td>\(c_2\)</td>
<td>\(d\)</td>
<td></td>
</tr>
</tbody></table>

<p><br></p>

<table><thead>
<tr>
<th>\(A\)</th>
<th>\(B\)</th>
<th>\(C\)</th>
<th>\(D\)</th>
<th>Dependency</th>
</tr>
</thead><tbody>
<tr>
<td>\(a\)</td>
<td>\(b\)</td>
<td>\(c\)</td>
<td>\(d_1\)</td>
<td></td>
</tr>
<tr>
<td>\(a\)</td>
<td>\(b\)</td>
<td>\(c_2\)</td>
<td>\(d\)</td>
<td></td>
</tr>
<tr>
<td>\(a\)</td>
<td>\(b\)</td>
<td>\(c_2\)</td>
<td>\(d_1\)</td>
<td>\(B \twoheadrightarrow C\)</td>
</tr>
<tr>
<td>\(a\)</td>
<td>\(b\)</td>
<td>\(c\)</td>
<td>\(d\)</td>
<td>\(B \twoheadrightarrow C\)</td>
</tr>
</tbody></table>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-113" style="background:;">
  <hgroup>
    <h2>Projecting MVDs</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have some FDs and MVDs for a relation \(R\) with attributes \(\mathcal{A}\)</li>
<li>Then we project \(R\) into \(R_1\) on some attributes \(\mathcal{B}\)</li>
<li>How do we know which dependencies hold on \(R_1\)?</li>
</ul>

<ul class = "build incremental">
<li>For a given possible MVD (and there are exponentially many), you can construct a
a tableau as before</li>
<li><p>Then run the chase algorithm and see if you find a <strong>row</strong> that supports the MVD</p></li>
<li><p>The FDs follow the same process</p></li>
<li><p>Set up a tableau as in the lossless join process</p></li>
<li><p>Chase the tableau, and make sure the final tableau has the same values in the given 
<strong>columns</strong></p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

    <slide class="backdrop"></slide>
  </slides>
  <div class="pagination pagination-small" id='io2012-ptoc' style="display:none;">
    <ul>
      <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=1 title='NA'>
         1
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=2 title='Functional Dependencies'>
         2
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=3 title='Functional Dependencies'>
         3
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=4 title='Functional Dependency Sanity Check'>
         4
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=5 title='A Sample Table'>
         5
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=6 title='Another Sample Table'>
         6
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=7 title='About Functional Dependencies and Relation Instances'>
         7
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=8 title='A Formal Definition of Keys'>
         8
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=9 title='A Formal Definition of Keys'>
         9
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=10 title='A Formal Definition of Keys'>
         10
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=11 title='Rules about Functional Dependencies'>
         11
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=12 title='Reasoning about Functional Dependencies'>
         12
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=13 title='Splitting Rule'>
         13
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=14 title='Combining Rule'>
         14
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=15 title='Trivial Functional Dependencies'>
         15
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=16 title='Trivial Dependency Rule'>
         16
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=17 title='Closure of a Set of Attributes'>
         17
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=18 title='Closure of a Set of Attributes'>
         18
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=19 title='Closure of a Set of Attributes'>
         19
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=20 title='Example'>
         20
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=21 title='Example'>
         21
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=22 title='Example'>
         22
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=23 title='Why the Closure Algorithm Works, Part 1'>
         23
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=24 title='Why the Closure Algorithm Works, Part 1'>
         24
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=25 title='Why the Closure Algorithm Works, Part 2'>
         25
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=26 title='Why the Closure Algorithm Works, Part 2'>
         26
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=27 title='Why the Closure Algorithm Works, Part 2'>
         27
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=28 title='Why the Closure Algorithm Works, Part 2'>
         28
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=29 title='Why the Closure Algorithm Works, Part 2'>
         29
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=30 title='Example: Transitive Rule'>
         30
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=31 title='All the (Needed) Inference Rules'>
         31
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=32 title='Minimal Functional Dependencies'>
         32
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=33 title='Functional Dependencies and Projections'>
         33
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=34 title='Projection of Functional Dependencies'>
         34
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=35 title='Projection of Functional Dependencies and Pragmatics'>
         35
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=36 title='Design of Relational Database Schemas'>
         36
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=37 title='Designing Relational Database Schemas'>
         37
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=38 title='Anomalies'>
         38
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=39 title='Decompositions'>
         39
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=40 title='Decompositions'>
         40
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=41 title='Decompositions'>
         41
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=42 title='Boyce-Codd Normal Form (BCNF)'>
         42
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=43 title='Boyce-Codd Normal Form (BCNF)'>
         43
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=44 title='Boyce-Codd Normal Form (BCNF)'>
         44
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=45 title='Boyce-Codd Normal Form (BCNF)'>
         45
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=46 title='Decomposing into BCNF'>
         46
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=47 title='Decomposing into BCNF'>
         47
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=48 title='Decomposing into BCNF'>
         48
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=49 title='Decomposing into BCNF'>
         49
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=50 title='Decomposing into BCNF'>
         50
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=51 title='Consequences of Decomposition into BCNF'>
         51
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=52 title='(Wanted) Properties of BCNF Decomposition'>
         52
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=53 title='No Anomalies: Redundancy'>
         53
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=54 title='No Anomalies: Redundancy'>
         54
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=55 title='No Anomalies: Update'>
         55
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=56 title='No Anomalies: Deletion'>
         56
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=57 title='Recoverability'>
         57
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=58 title='Recoverability'>
         58
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=59 title='Recoverability'>
         59
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=60 title='Recoverability'>
         60
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=61 title='Recoverability'>
         61
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=62 title='Lossless Joins'>
         62
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=63 title='The Chase Test for Lossless Joins'>
         63
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=64 title='The Chase Test for Lossless Joins'>
         64
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=65 title='The Chase Test for Lossless Joins'>
         65
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=66 title='The Chase Test for Lossless Joins'>
         66
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=67 title='The Chase Test for Lossless Joins'>
         67
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=68 title='The Chase Test for Lossless Joins'>
         68
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=69 title='The Chase Test for Lossless Joins'>
         69
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=70 title='The Chase Test for Lossless Joins'>
         70
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=71 title='The Chase Test for Lossless Joins'>
         71
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=72 title='Example of Decomposition into BCNF'>
         72
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=73 title='Example of Decomposition into BCNF'>
         73
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=74 title='Example of Decomposition into BCNF'>
         74
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=75 title='Example of Decomposition into BCNF'>
         75
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=76 title='Example of Decomposition into BCNF'>
         76
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=77 title='Example of Decomposition into BCNF'>
         77
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=78 title='Example of Decomposition into BCNF'>
         78
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=79 title='Example of Decomposition into BCNF'>
         79
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=80 title='Example of Decomposition into BCNF'>
         80
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=81 title='Example of Decomposition into BCNF'>
         81
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=82 title='Example of Decomposition into BCNF'>
         82
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=83 title='Example of Decomposition into BCNF (Important Aside)'>
         83
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=84 title='Example of Decomposition into BCNF (Important Aside)'>
         84
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=85 title='Dependency Preservation'>
         85
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=86 title='Third Normal Form (3NF)'>
         86
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=87 title='Third Normal Form (3NF)'>
         87
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=88 title='Third Normal Form (3NF)'>
         88
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=89 title='Third Normal Form Guarantees'>
         89
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=90 title='Decomposition into 3NF'>
         90
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=91 title='Example Decomposition into 3NF'>
         91
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=92 title='Example Decomposition into 3NF: Step 1'>
         92
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=93 title='Example Decomposition into 3NF: Step 2'>
         93
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=94 title='Example Decomposition into 3NF: Step 3'>
         94
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=95 title='Why the Decomposition into 3NF Works'>
         95
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=96 title='Multivalued Dependencies'>
         96
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=97 title='Multivalued Dependencies'>
         97
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=98 title='Multivalued Dependencies'>
         98
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=99 title='Multivalued Dependencies'>
         99
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=100 title='Multivalued Dependencies'>
         100
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=101 title='Multivalued Dependencies'>
         101
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=102 title='Rules for Multivalued Dependencies'>
         102
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=103 title='Caveat on Rules for Multivalued Dependencies'>
         103
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=104 title='More Rules for Multivalued Dependencies'>
         104
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=105 title='Fourth Normal Form (4NF)'>
         105
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=106 title='Relationship among Normal Forms'>
         106
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=107 title='Algorithms for MVDs'>
         107
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=108 title='The Closure Algorithm'>
         108
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=109 title='The Chase Algorithm for MVDs'>
         109
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=110 title='The Chase Algorithm for Inferring MVDs'>
         110
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=111 title='The Chase Algorithm for Inferring MVDs'>
         111
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=112 title='The Chase Algorithm for Inferring MVDs'>
         112
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=113 title='Projecting MVDs'>
         113
      </a>
    </li>
  </ul>
  </div>  <!--[if IE]>
    <script 
      src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js">  
    </script>
    <script>CFInstall.check({mode: 'overlay'});</script>
  <![endif]-->
</body>
  <!-- Load Javascripts for Widgets -->
  <script src="libraries/widgets/bootstrap/js/bootstrap.min.js"></script>
<script src="libraries/widgets/bootstrap/js/bootbox.min.js"></script>

  <!-- MathJax: Fall back to local if CDN offline but local image fonts are not supported (saves >100MB) -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true
      }
    });
  </script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- <script src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script> -->
  <script>window.MathJax || document.write('<script type="text/x-mathjax-config">MathJax.Hub.Config({"HTML-CSS":{imageFont:null}});<\/script><script src="libraries/widgets/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"><\/script>')
</script>
<script>  
  $(function (){ 
    $("#example").popover(); 
    $("[rel='tooltip']").tooltip(); 
  });  
  </script>  
  <!-- LOAD HIGHLIGHTER JS FILES -->
  <script src="libraries/highlighters/highlight.js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <!-- DONE LOADING HIGHLIGHTER JS FILES -->
   
  </html>