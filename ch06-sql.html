<!DOCTYPE html>
<html>
<head>
  <title>COSC 4820 Database Systems</title>
  <meta charset="utf-8">
  <meta name="description" content="COSC 4820 Database Systems">
  <meta name="author" content="Ruben Gamboa">
  <meta name="generator" content="slidify" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/default.css" media="all" >
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/phone.css" 
    media="only screen and (max-device-width: 480px)" >
  <link rel="stylesheet" href="libraries/frameworks/io2012/css/slidify.css" >
  <link rel="stylesheet" href="libraries/highlighters/highlight.js/css/tomorrow.css" />
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->  <link rel=stylesheet href="libraries/widgets/bootstrap/css/bootstrap.css"></link>
<link rel=stylesheet href="./assets/css/ribbons.css"></link>

  
  <!-- Grab CDN jQuery, fall back to local if offline -->
  <script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.7.min.js"></script>
  <script>window.jQuery || document.write('<script src="libraries/widgets/quiz/js/jquery.js"><\/script>')</script> 
  <script data-main="libraries/frameworks/io2012/js/slides" 
    src="libraries/frameworks/io2012/js/require-1.0.8.min.js">
  </script>
  
  

</head>
<body style="opacity: 0">
  <slides class="layout-widescreen">
    
    <!-- LOGO SLIDE -->
        <slide class="title-slide segue nobackground">
  <hgroup class="auto-fadein">
    <h1>COSC 4820 Database Systems</h1>
    <h2>The Database Language SQL</h2>
    <p>Ruben Gamboa<br/>Professor</p>
  </hgroup>
  <article></article>  
</slide>
    

    <!-- SLIDES -->
    <slide class="" id="slide-1" style="background:;">
  <article data-timings="">
    <style>
.title-slide {
     background-color: #EDE0CF; /* CBE7A5; #EDE0CF; ; #CA9F9D*/
     background-image: url(assets/img/uw-logo-large.png);
     background-repeat: no-repeat;
     background-position: center top;
   }
</style>

<h2>Chapter Overview</h2>

<ul>
<li>The purpose of this chapter is to introduce <strong>SQL</strong></li>
<li><strong>SQL</strong> is the <strong>Structured Query Language</strong></li>
<li>It is the standard language for querying and manipulating database
<br><br></li>
<li>Note that SQL is a &quot;soft&quot; standard</li>
<li>There are lots of dialects</li>
<li>We&#39;ll stick close to the official ANSI standard, but you should always consult your database manual for details</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-2" style="background:;">
  <hgroup>
    <h1>Simple Queries in SQL</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-3" style="background:;">
  <hgroup>
    <h2>Using SQL</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>SQL is generally used in one of three ways:

<ol>
<li>A user can type SQL into a command area</li>
<li>A programmer can create a SQL query and it&#39;s run when the program executes</li>
<li>A program can construct a query dynamically
<br><br></li>
</ol></li>
<li>Option 1 is the one we&#39;ll use most in this class</li>
<li>But it&#39;s actually the least common option
<br><br></li>
<li>Also, a lot of the programs that execute database queries are web applications</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-4" style="background:;">
  <hgroup>
    <h2>Simple Queries in SQL</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The basic query in SQL has the structure SELECT ... FROM ... WHERE ...
<br><br></li>
<li>After the SELECT is a list of <strong>attributes</strong> or a single *

<ul>
<li>&quot;SELECT&quot; should really have been &quot;PROJECT&quot;
<br><br></li>
</ul></li>
<li>After the FROM is a list of <strong>relations</strong></li>
<li>The relations are implicitly cross-producted (if that&#39;s a word)
<br><br></li>
<li>After the WHERE is a <strong>condition</strong></li>
<li>This is the selection part of the query</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-5" style="background:;">
  <hgroup>
    <h2>Simple Queries in SQL</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Consider this schema:</li>
</ul>

<pre><code>Movies(title , year , length , genre , studioName , producerC#) 
StarsIn(movieTitle , movieYear , starName) 
MovieStar(name , address , gender , birthdate) 
MovieExec(name , address , cert# , netWorth) 
Studio(name , address , presC#) 
</code></pre>

<ul>
<li>A basic query may be</li>
</ul>

<pre><code>SELECT *
  FROM Movies
 WHERE studioName = &#39;Lucasfilm&#39;
   AND year = 1977
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-6" style="background:;">
  <hgroup>
    <h2>Reading SQL Queries</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Start by looking at the FROM clause</li>
<li>That tells you what relations are being considered</li>
<li>Remember that you can only look at one tuple from each relation at a time
<br><br></li>
<li>Then look at the WHERE clause</li>
<li>This tells you which tuples are chosen
<br><br></li>
<li>Finally, look at the SELECT clause</li>
<li>That tells you which attributes will make it to the answer</li>
</ul>

<pre><code>SELECT *
  FROM Movies
 WHERE studioName = &#39;Lucasfilm&#39;
   AND year = 1977
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-7" style="background:;">
  <hgroup>
    <h2>SQL Queries and Relational Algebra</h2>
  </hgroup>
  <article data-timings="">
    <p>Here is a generic SQL query</p>

<pre><code>SELECT L
  FROM R
 WHERE C
</code></pre>

<p>This converts into the the relational algebra query
\[\pi_L(\sigma_C(R))\]</p>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-8" style="background:;">
  <hgroup>
    <h2>Projection in SQL</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>SELECT title, year
  FROM Movies
 WHERE studioName = &#39;Lucasfilm&#39;
   AND year = 1977
</code></pre>

<table><thead>
<tr>
<th>Title</th>
<th>Year</th>
</tr>
</thead><tbody>
<tr>
<td>Star Wars</td>
<td>1977</td>
</tr>
</tbody></table>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-9" style="background:;">
  <hgroup>
    <h2>Extended Projection in SQL</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>SELECT title AS Name, year Released, length/60 AS Duration
  FROM Movies
 WHERE studioName = &#39;Lucasfilm&#39;
   AND year = 1977
</code></pre>

<table><thead>
<tr>
<th>Name</th>
<th>Released</th>
<th>Duration</th>
</tr>
</thead><tbody>
<tr>
<td>Star Wars</td>
<td>1977</td>
<td>2.05</td>
</tr>
</tbody></table>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-10" style="background:;">
  <hgroup>
    <h2>Selection in SQL</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Selection is accomplished with the condition in the FROM clause</li>
<li>The condition syntax in SQL is actually more powerful than the syntax in relational algebra</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-11" style="background:;">
  <hgroup>
    <h2>Conditions in SQL</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The base condition is a comparison, with the operators

<ul>
<li>=, &lt;, &gt;, &lt;=, &gt;=, &lt;&gt;</li>
<li>Many databases also support != instead of &lt;&gt;
<br><br></li>
</ul></li>
<li>The values that can be compared can be

<ul>
<li>constants, e.g., &#39;Fred&#39; or 42</li>
<li>attributes of the relations listed in the FROM clause, e.g., year</li>
<li>arithmetic expressions</li>
<li>date expressions</li>
<li>string expressions</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-12" style="background:;">
  <hgroup>
    <h2>Conditions in SQL</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Base conditions can be combined using the familiar relational operators

<ul>
<li>AND</li>
<li>OR</li>
<li>NOT
<br><br></li>
</ul></li>
<li>You can also use parentheses to groups of conditions, e.g.,</li>
</ul>

<pre><code>SELECT title AS Name, year Released, length/60 AS Duration
  FROM Movies
 WHERE studioName = &#39;Lucasfilm&#39;
   AND (   year = 1977
        OR year = 1980 )
</code></pre>

<ul>
<li>But not all databases support this</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-13" style="background:;">
  <hgroup>
    <h2>String Comparisons in SQL</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Strings can also be compared using 

<ul>
<li>=, &lt;, &gt;, &lt;=, &gt;=, &lt;&gt;
<br><br></li>
</ul></li>
<li>The meaning of the comparisons depends on the (natural) language used in the database</li>
<li>Basically, comparisons are done using lexicographic ordering</li>
<li>That&#39;s a fancy word for &quot;dictionary ordering&quot;
<br><br></li>
<li>The very good question is &quot;What language is the dictionary in?&quot;</li>
<li>Maybe your database runs in en_US or en_GB</li>
<li>Or maybe it&#39;s fr_CA or fr_FR</li>
<li>Keep in mind that the ordering of words may differ depending on the specific dialect of a language!</li>
<li>This is called the <strong>collation</strong></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-14" style="background:;">
  <hgroup>
    <h2>Locales in SQL</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>What is the locale of your database?
<br><br></li>
<li>You can ignore this, and hope that the database is in en_US</li>
<li>(Or whatever language you prefer)
<br><br></li>
<li>But keep in mind that the DBA can change this setting (possibly breaking your program)
<br><br></li>
<li>It is best to be explicit and <strong>set the locale</strong> by yourself</li>
<li>This setting affects your <strong>session</strong> only</li>
<li>So your queries always run in the same locale</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-15" style="background:;">
  <hgroup>
    <h2>String Operators</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We&#39;re all familiar with the basic arithmetic operators, e.g., +, -, *, /
<br><br></li>
<li>There are also string operators:

<ul>
<li><strong>Concatenation:</strong>  &#39;hello&#39; || &#39; &#39; || &#39;world&#39;
<br><br></li>
</ul></li>
<li>The problem is that this isn&#39;t standard <strong>at all</strong>

<ul>
<li>&#39;hello&#39; + &#39; &#39; + &#39;world&#39;</li>
<li>concat(&#39;hello&#39;, concat(&#39; &#39;, &#39;world&#39;))</li>
</ul></li>
</ul>

<ul class = "build incremental">
<li>There are may other string operators, but check your database manual for the syntax!

<ul>
<li><strong>Substring</strong></li>
<li><strong>Replace</strong></li>
<li><strong>Touppercase</strong></li>
<li><strong>Tonumber</strong></li>
<li><strong>Todate</strong></li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-16" style="background:;">
  <hgroup>
    <h2>String Comparisons</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We can compare with 

<ul>
<li>=, &lt;, &gt;, &lt;=, &gt;=, &lt;&gt;
<br><br></li>
</ul></li>
<li>But it also makes sense to compare strings using partial matches</li>
<li>E.g., we want to find all strings with names that look like *.SQL
<br><br></li>
<li>The LIKE operator does this</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-17" style="background:;">
  <hgroup>
    <h2>String LIKE Comparisons</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>LIKE compares a string and a <strong>pattern</strong>:

<ul>
<li>string LIKE pattern</li>
<li>string NOT LIKE pattern
<br><br></li>
</ul></li>
<li>The pattern is a string with some special <strong>matching</strong> (also <strong>globbing</strong>) characters

<ul>
<li>% matches zero or more characters</li>
<li>_ matches precisely one character (any character)</li>
</ul></li>
</ul>

<pre><code>SELECT *
  FROM Movies
 WHERE title LIKE &#39;Star %&#39;
   AND title LIKE &#39;% Wars&#39;
</code></pre>

<ul>
<li>This will find &#39;Star Wars&#39;</li>
<li>It will also find &#39;Star Fairies and the Border Wars&#39;</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-18" style="background:;">
  <hgroup>
    <h2>String LIKE Comparisons</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Is this query TRUE or FALSE?

<ul>
<li>&#39;star wars&#39; LIKE &#39;Star %&#39;
<br><br></li>
</ul></li>
<li>Sadly, it depends on your database and settings</li>
<li>Remember the collations?</li>
<li>Some collations are case-sensitive, and some are not</li>
<li>So it depends on which collation you&#39;re using!
<br><br></li>
<li>By default, in en_US with default collation, LIKE is case insensitive</li>
<li>So the condition is TRUE
<br><br></li>
<li>Some databases support the comparison operator CLIKE, which is a case-sensitive version of LIKE</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-19" style="background:;">
  <hgroup>
    <h2>Date and Time Comparisons</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>SQL supports the Date and Time data types</li>
<li>But there is <strong>great variety</strong> in the syntax between different databases</li>
<li>There are also differences when it comes to precisely what date and a time means

<ul>
<li>In some databases, the Date actually has a Time component</li>
<li>In others, it does not</li>
<li>Some databases have a DateTime object</li>
<li>That may mean it has a Date and a Time</li>
<li>Or it may mean that Date has a Date and Time, but DateTime has more resolution than Date (e.g., it supports milliseconds)
<br><br></li>
</ul></li>
<li><strong>Check your database manual!</strong></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-20" style="background:;">
  <hgroup>
    <h2>ANSI Date and Time Constants</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>DATE &#39;yyyy-mm-dd&#39;

<ul>
<li>DATE &#39;2019-03-05&#39;</li>
<li>DATE &#39;2019-03-10&#39;
<br><br></li>
</ul></li>
<li>TIME &#39;hh:mm:ss.ddd&#39;

<ul>
<li>TIME &#39;03:15:00&#39;</li>
<li>TIME &#39;15:30:00&#39;</li>
<li>TIME &#39;15:30:00.23&#39;</li>
<li>TIME &#39;15:30:00.938548&#39;</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-21" style="background:;">
  <hgroup>
    <h2>ANSI Date and Time Constants</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>TIME &#39;hh:mm:ss.ddd+h:mm&#39; or TIME &#39;hh:mm:ss.ddd-h:mm&#39;

<ul>
<li>TIME &#39;03:15:00-7:00&#39;</li>
<li>TIME &#39;03:15:00-6:00&#39;
<br><br></li>
</ul></li>
<li>TIMESTAMP &#39;yyyy-mm-dd hh:mm:ss.ddd&#39;

<ul>
<li>TIMESTAMP &#39;2019-03-05 15:15:00&#39;</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-22" style="background:;">
  <hgroup>
    <h2>ANSI Date and Time Conditions</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We can use the date and time constants in conditions</li>
</ul>

<pre><code>SELECT *
  FROM Movies
 WHERE releaseDate &gt;= DATE &#39;2019-03-05&#39;
   AND releaseDate &lt;= DATE &#39;2019-03-15&#39;
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-23" style="background:;">
  <hgroup>
    <h2>NULL Values</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>NULL values appear for a multitude of reasons

<ol>
<li>There is some value, but we don&#39;t know what it is</li>
<li>There is no possible value for this particular field</li>
<li>The value for this particular field is a secret
<br><br></li>
</ol></li>
<li>So how do we handle NULL values in

<ul>
<li>expressions?</li>
<li>conditions?</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-24" style="background:;">
  <hgroup>
    <h2>NULL Values in Expressions</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>If any input to an expression is NULL, the value of the expression is NULL
<br><br></li>
<li>2 + NULL = NULL</li>
<li>NULL - NULL = NULL</li>
<li>0 * NULL = NULL</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-25" style="background:;">
  <hgroup>
    <h2>NULL Values in Conditions</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>If an input to a condition is NULL, the value of the condition if UNKNOWN</li>
<li>That means that conditions can be TRUE, FALSE, or UNKNOWN</li>
<li>These three-value logic has the following truth tables</li>
</ul>

<div style='float:left;width:48%;'>
  <table><thead>
<tr>
<th>X</th>
<th>Y</th>
<th>X AND Y</th>
<th>X OR Y</th>
</tr>
</thead><tbody>
<tr>
<td>TRUE</td>
<td>TRUE</td>
<td>TRUE</td>
<td>TRUE</td>
</tr>
<tr>
<td>TRUE</td>
<td>FALSE</td>
<td>FALSE</td>
<td>TRUE</td>
</tr>
<tr>
<td>TRUE</td>
<td>UNKNOWN</td>
<td>UNKNOWN</td>
<td>TRUE</td>
</tr>
<tr>
<td>FALSE</td>
<td>TRUE</td>
<td>FALSE</td>
<td>TRUE</td>
</tr>
<tr>
<td>FALSE</td>
<td>FALSE</td>
<td>FALSE</td>
<td>FALSE</td>
</tr>
<tr>
<td>FALSE</td>
<td>UNKNOWN</td>
<td>FALSE</td>
<td>UNKNOWN</td>
</tr>
<tr>
<td>UNKNOWN</td>
<td>TRUE</td>
<td>UNKNOWN</td>
<td>TRUE</td>
</tr>
<tr>
<td>UNKNOWN</td>
<td>FALSE</td>
<td>FALSE</td>
<td>UNKNOWN</td>
</tr>
<tr>
<td>UNKNOWN</td>
<td>UNKNOWN</td>
<td>UNKNOWN</td>
<td>UNKNOWN</td>
</tr>
</tbody></table>

</div>
<div style='float:right;width:48%;'>
  <table><thead>
<tr>
<th>X</th>
<th>NOT X</th>
</tr>
</thead><tbody>
<tr>
<td>TRUE</td>
<td>FALSE</td>
</tr>
<tr>
<td>FALSE</td>
<td>TRUE</td>
</tr>
<tr>
<td>UNKNOWN</td>
<td>UNKNOWN</td>
</tr>
</tbody></table>

</div>
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-26" style="background:;">
  <hgroup>
    <h2>Three-valued Conditions</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>A condition may be TRUE, FALSE, or UNKNOWN
<br><br></li>
<li>If it&#39;s TRUE, we select the row and print the result</li>
<li>If it&#39;s FALSE, we do not select the row, so no result is printed</li>
<li>If it&#39;s UNKNOWN, we treat it as FALSE -- but only in the final step</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-27" style="background:;">
  <hgroup>
    <h2>NULL Values in Conditions</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Notice that NOT UNKNOWN is UNKNOWN
<br><br></li>
<li>So the following condition does not print all rows</li>
</ul>

<pre><code>SELECT *
  FROM Movies
 WHERE length &gt; 200
    OR length &lt;= 200
</code></pre>

<ul>
<li>It only returns the rows that have a non-NULL length!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-28" style="background:;">
  <hgroup>
    <h2>Ordering the Output</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Even though we claim that results are sets or bags, we sometimes want to answer the rows in the result
<br><br></li>
<li>We do so with the ORDER BY clause, which we put at the end of the query</li>
<li>You can order by one or more attributes</li>
<li>And you can choose to order in ASCending (default) or DESCending order</li>
</ul>

<pre><code>  SELECT *
    FROM Movies
ORDER BY year, length DESC
</code></pre>

<ul>
<li>The Movies are sorted by year first, i.e., Movies made in 1990, then in 1991, then 1992, etc.</li>
<li>Within a year, the Movies are sorted from longest to shortest</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-29" style="background:;">
  <hgroup>
    <h1>Queries Involving More Than One Relation</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-30" style="background:;">
  <hgroup>
    <h2>Queries Involving More Than One Relation</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>If a query needs data from more than one relation, simply list all the needed relations in the FROM clause
<br><br></li>
<li>The query proceeds by taking the cross-product of all the relations in the FROM clause</li>
<li>Then, the condition in the WHERE clause tests whether a particular combination of tuples passes</li>
<li>If the combination passes, the data in the SELECT clause is displayed</li>
</ul>

<pre><code>SELECT title, name
  FROM Movies, MovieExecs
 WHERE title = &#39;Star Wars&#39;
   AND producerC# = cert#
</code></pre>

<ul>
<li>Notice this is almost like a join</li>
<li>And remember that \(X \bowtie Y = \sigma(X \times Y)\)</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-31" style="background:;">
  <hgroup>
    <h2>Disambiguating Attributes</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>But what about the following schema</li>
</ul>

<pre><code>Books(_isbn_, title, authorid)
Authors(authorid, name)
</code></pre>

<ul>
<li>How can we compare authorid in Books with authorid in Authors?</li>
<li>SQL notation is R.A, where R is a relation name and A one of its attributes</li>
</ul>

<pre><code>SELECT title, name
  FROM Books, Authors
 WHERE Books.authorid = Authors.authorid
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-32" style="background:;">
  <hgroup>
    <h2>Disambiguating Attributes</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>What if we need to use a relation more than once?
<br><br></li>
<li><strong>Tuple variables</strong> allow us to rename a relation</li>
<li>The new name can be used to disambiguate attributes</li>
</ul>

<pre><code>SELECT title, name
  FROM Books B1, Books B2, Authors
 WHERE B1.authorid = Authors.authorid
   AND B2.authorid = Authors.authorid
   AND B1.isbn &lt;&gt; B2.isbn
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-33" style="background:;">
  <hgroup>
    <h2>Sidebar: Hint on Multiple Copies</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Instead of using &lt;&gt;, use &lt;</li>
<li>That way, you only get one copy of each pair</li>
</ul>

<pre><code>SELECT title, name
  FROM Books B1, Books B2, Authors
 WHERE B1.authorid = Authors.authorid
   AND B2.authorid = Authors.authorid
   AND B1.isbn &lt; B2.isbn
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-34" style="background:;">
  <hgroup>
    <h2>SQL Queries and Relational Algebra</h2>
  </hgroup>
  <article data-timings="">
    <p>Here is a generic SQL query that uses multiple relations</p>

<pre><code>SELECT L
  FROM R, S
 WHERE C
</code></pre>

<p>This converts into the the relational algebra query
\[\pi_L(\sigma_C(R \times S))\]</p>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-35" style="background:;">
  <hgroup>
    <h2>Set Operations in SQL</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Union-compatible queries can be combined using the operators

<ul>
<li>UNION</li>
<li>INTERSECT</li>
<li>EXCEPT</li>
</ul></li>
<li>Many databases support only UNION, however</li>
<li><strong>Check your database manual!</strong></li>
</ul>

<pre><code>(SELECT title, name
   FROM Movies, MovieExecs
  WHERE title = &#39;Star Wars&#39;
    AND producerC# = cert#)
UNION
(SELECT title, name
   FROM Movies, MovieExecs
  WHERE title = &#39;The Empire Strikes Back&#39;
    AND producerC# = cert#)
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-36" style="background:;">
  <hgroup>
    <h2>Set Operations in SQL</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>(SELECT title, year
   FROM Movies
 WHERE studioName = &#39;Lucasfilm&#39;)
EXCEPT
(SELECT title, year
   FROM Movies
  WHERE year &gt;= 1995)
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-37" style="background:;">
  <hgroup>
    <h1>Subqueries</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-38" style="background:;">
  <hgroup>
    <h2>Subqueries</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li><p>Subqueries come very naturally -- <em>too</em> naturally -- to computer scientists</p></li>
<li><p>In a nutshell, the results of a subquery can be used</p>

<ul>
<li>in place of a relation (e.g., Students who are COSC majors)</li>
<li>in place of a single value (e.g., the CRN for this class)</li>
<li>in place of a list of values (e.g., the CRNs for classes I&#39;m teaching this semester)</li>
</ul></li>
<li><p>Of course, subqueries can have subqueries, which can have more nested subqueries, etc.</p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-39" style="background:;">
  <hgroup>
    <h2>Subqueries that Produce Single Values</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Generally speaking, a query have many rows and many columns</li>
<li>But some queries return only a single row and a single column</li>
</ul>

<pre><code>SELECT crn
  FROM Courses
 WHERE year = 2019
   AND semester = &#39;Spring&#39;
   AND dept = &#39;COSC&#39;
   AND cnumber = &#39;4820&#39;
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-40" style="background:;">
  <hgroup>
    <h2>Subqueries that Produce Single Values</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We can use that query to find all the students in this class</li>
</ul>

<pre><code>SELECT first_name, last_name
  FROM Students, Enrolled
 WHERE Students.wnumber = Enrolled.wnumber
   AND Enrolled.crn = (SELECT crn
                         FROM Courses
                        WHERE year = 2019
                          AND semester = &#39;Spring&#39;
                          AND dept = &#39;COSC&#39;
                          AND cnumber = &#39;4820&#39;)
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-41" style="background:;">
  <hgroup>
    <h2>How Subqueries Are Executed</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>SELECT first_name, last_name
  FROM Students, Enrolled
 WHERE Students.wnumber = Enrolled.wnumber
   AND Enrolled.crn = (SELECT crn
                         FROM Courses
                        WHERE year = 2019   AND semester = &#39;Spring&#39;
                          AND dept = &#39;COSC&#39; AND cnumber = &#39;4820&#39;)
</code></pre>

<ul>
<li>First, execute the innermost query, so we find the CRN for this course</li>
<li>Then, replace the subquery with the result, which is 21287</li>
<li>Now, execute the outer query</li>
</ul>

<pre><code>SELECT first_name, last_name
  FROM Students, Enrolled
 WHERE Students.wnumber = Enrolled.wnumber
   AND Enrolled.crn = 21287
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-42" style="background:;">
  <hgroup>
    <h2>The Problem with Subqueries</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>There&#39;s a different way to get the list of students taking this course:</li>
</ul>

<pre><code>SELECT first_name, last_name
  FROM Students, Enrolled, Courses
 WHERE Students.wnumber = Enrolled.wnumber
   AND Enrolled.crn = Courses.crn
   AND year = 2019   AND semester = &#39;Spring&#39;
   AND dept = &#39;COSC&#39; AND cnumber = &#39;4820&#39;
</code></pre>

<ul>
<li>This may be <strong>considerably more efficient</strong> than what we proposed above</li>
<li>Some databases will automatically convert the subquery into a join</li>
<li>But some databases won&#39;t even try</li>
<li>And not all databases will succeed in all cases
<br><br></li>
<li>When possible, use joins instead of subqueries!!!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-43" style="background:;">
  <hgroup>
    <h2>Conditions Involving Relations</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we have a subquery \(S\)</li>
<li><p>There are many things we could ask about the results of \(S\)</p>

<ul>
<li>Are there any results in \(S\)?</li>
<li>Is a particular entry in \(S\)?</li>
<li>Are all the entries in \(S\) bigger than some value?</li>
<li>Is any entry in \(S\) bigger than some value?</li>
</ul></li>
<li><p>SQL contains special operators for each of these cases</p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-44" style="background:;">
  <hgroup>
    <h2>Is the Result Empty?</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>What classes have no students?</li>
</ul>

<pre><code>SELECT crn
  FROM Courses
 WHERE NOT EXISTS ( SELECT *
                      FROM Enrolled 
                     WHERE Courses.crn = Enrolled.crn )
</code></pre>

<ul>
<li><strong>Spoilers:</strong> Notice that we would not be able to execute the nested query by itself first</li>
<li>Such queries are called <strong>correlated subqueries</strong></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-45" style="background:;">
  <hgroup>
    <h2>Does the Result Contain a Specific Value?</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>What students are in any of my classes?</li>
</ul>

<pre><code>SELECT first_name, last_name
  FROM Students, Enrolled
 WHERE Students.wnumber = Enrolled.wnumber
   AND Enrolled.crn IN (SELECT crn
                          FROM Courses
                         WHERE year = 2019
                           AND semester = &#39;Spring&#39;
                           AND facultyId = (SELECT id
                                              FROM Faculty
                                             WHERE first_name = &#39;Ruben&#39;
                                               AND last_name = &#39;Gamboa&#39;))
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-46" style="background:;">
  <hgroup>
    <h2>Does the Result Contain a Specific Value?</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>What producers have worked with Harrison Ford?</li>
</ul>

<pre><code>SELECT name
  FROM MovieExec
 WHERE cert# IN (SELECT producerC#
                   FROM Movies
                  WHERE (title, year) IN (SELECT movieTitle, movieYear
                                            FROM StarsIn
                                           WHERE starName = &#39;Harrison Ford&#39;))
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-47" style="background:;">
  <hgroup>
    <h2>Are All the Entries Bigger than Some Value?</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>What stars are completely bankable?</li>
</ul>

<pre><code>SELECT name
  FROM MovieStars
 WHERE 50000000 &lt;= ALL (SELECT profit
                          FROM Movies
                         WHERE MovieStars.name IN (SELECT starName
                                                     FROM StarsIn
                                                    WHERE movieTitle = title
                                                      AND movieYear = year))
</code></pre>

<ul>
<li>Notice these subqueries are also <strong>correlated</strong></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-48" style="background:;">
  <hgroup>
    <h2>Are Some Entries Bigger than Some Value?</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>What stars are bankable at least some of the time?</li>
</ul>

<pre><code>SELECT name
  FROM MovieStars
 WHERE 50000000 &lt;= ANY (SELECT profit
                          FROM Movies
                         WHERE MovieStars.name IN (SELECT starName
                                                     FROM StarsIn
                                                    WHERE movieTitle = title
                                                      AND movieYear = year))
</code></pre>

<ul>
<li>Notice these subqueries are also <strong>correlated</strong></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-49" style="background:;">
  <hgroup>
    <h2>Correlated Subqueries</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>What is the first movie made by each movie star?</li>
</ul>

<pre><code>SELECT MovieStars.name, FirstMovie.title, FirstMovie.year
  FROM MovieStars, Movie AS FirstMovie, StarsIn
 WHERE StarsIn.starName = MovieStars.name
   AND StarsIn.movieTitle = FirstMovie.title
   AND StarsIn.movieYear = FirstMovie.year
   AND NOT EXISTS ( SELECT *
                      FROM Movie, StarsIn
                     WHERE StarsIn.starName = MovieStars.name
                       AND StarsIn.movieTitle = Movie.title
                       AND StarsIn.movieYear = Movie.year
                       AND Movie.year &lt; FirstMovie.year )
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-50" style="background:;">
  <hgroup>
    <h2>Subqueries in FROM Clauses</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>A subquery returns a set of tuples</li>
<li>So it&#39;s really the same thing as a relation
<br><br></li>
<li>That&#39;s the rationale behind allowing subqueries in FROM clauses</li>
<li>If you do this, you should give the subquery a name, so you can use
it for disambiguating attribute names</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-51" style="background:;">
  <hgroup>
    <h2>Subqueries in FROM Clauses</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>What actor has starred in the most movies?</li>
</ul>

<pre><code>SELECT name
  FROM (SELECT MovieStars.name, COUNT(*) AS movieCount
          FROM MovieStars, StarsIn
         WHERE MovieStars.name = StarsIn.name 
         GROUP BY name) AS StarMovieCount
 WHERE NOT EXISTS (SELECT *
                     FROM StarMovieCount AS SMC2
                    WHERE SMC2.movieCount &gt; StarMovieCount.movieCount)
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-52" style="background:;">
  <hgroup>
    <h2>SQL Join</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Recall that the FROM clause contains a <strong>list of relations</strong></li>
<li>Actually, that&#39;s not quite true</li>
<li>What it contains is a restricted relational algebra expression</li>
<li>The &quot;,&quot; operator is actually the <strong>set product</strong> operator</li>
<li>And it can be written as CROSS JOIN</li>
</ul>

<pre><code>SELECT starName, movieTitle, movieYear, genre
  FROM StarsIn, Movies
 WHERE StarsIn.title = Movies.title
   AND StarsIn.year = Movies.year
   AND Movies.length &gt; 120
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-53" style="background:;">
  <hgroup>
    <h2>SQL Join</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>SELECT starName, movieTitle, movieYear, genre
  FROM StarsIn CROSS JOIN Movies
 WHERE StarsIn.title = Movies.title
   AND StarsIn.year = Movies.year
   AND Movies.length &gt; 120
</code></pre>

<ul>
<li>There is no compelling reason for using CROSS JOIN instead of &quot;,&quot;</li>
<li>And many databases don&#39;t support the CROSS JOIN syntax, anyway</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-54" style="background:;">
  <hgroup>
    <h2>SQL Theta Joins</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>You can place an entire theta join on the FROM clause</li>
<li>Use the JOIN ... ON syntax</li>
</ul>

<pre><code>SELECT starName, movieTitle, movieYear, genre
  FROM StarsIn JOIN Movies ON StarsIn.title = Movies.title
                          AND StarsIn.year = Movies.year
 WHERE Movies.length &gt; 120
</code></pre>

<ul>
<li>This is really a matter of style</li>
<li>Some database programmers prefer to place the &quot;join&quot; conditions in the FROM,
and the &quot;selection&quot; conditions in the WHERE</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-55" style="background:;">
  <hgroup>
    <h2>Natural Joins</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Natural joins are even easier</li>
<li>Just use NATURAL JOIN and the tables will be joined according to the common attributes</li>
</ul>

<pre><code>SELECT name, title, year, genre
  FROM StarsIn NATURAL JOIN Movies
 WHERE Movies.length &gt; 120
</code></pre>

<ul>
<li>Note: For this to work, the StarsIn relation must have the same attribute names as Movies</li>
<li>This is rarely the case, so natural joins are not as common as you may expect</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-56" style="background:;">
  <hgroup>
    <h2>Outer Joins</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Finally, we can have an OUTER JOIN</li>
<li>This can be combined with NATURAL or not</li>
</ul>

<pre><code>SELECT name, title, year, genre
  FROM StarsIn NATURAL FULL OUTER JOIN Movies
 WHERE Movies.length &gt; 120
</code></pre>

<pre><code>SELECT starName, movieTitle, movieYear, genre
  FROM StarsIn FULL OUTER JOIN Movies ON StarsIn.title = Movies.title
                                     AND StarsIn.year = Movies.year
 WHERE Movies.length &gt; 120
</code></pre>

<ul>
<li>A FULL outer join preserves tuples in both relations</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-57" style="background:;">
  <hgroup>
    <h2>Left and Right Outer Joins</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Of course, SQL supports both LEFT and RIGHT OUTER JOINS</li>
</ul>

<pre><code>SELECT name, title, year, genre
  FROM StarsIn NATURAL LEFT OUTER JOIN Movies
 WHERE Movies.length &gt; 120
</code></pre>

<pre><code>SELECT name, title, year, genre
  FROM StarsIn NATURAL RIGHT OUTER JOIN Movies
 WHERE Movies.length &gt; 120
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-58" style="background:;">
  <hgroup>
    <h2>Reality and Outer Joins</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Not all databases support all the different types of outer joins
<br><br></li>
<li>It is very common for LEFT OUTER JOIN to be supported</li>
<li>But none of the other OUTER JOIN combinations are necessarily supported
<br><br></li>
<li><strong>Check your database manual!</strong></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-59" style="background:;">
  <hgroup>
    <h1>Full-Relation Operations</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-60" style="background:;">
  <hgroup>
    <h2>Full-Relation Operations</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>By design, SQL conditions look at each row separately</li>
<li>There is no notion of looking at more than one row at a time</li>
<li>That&#39;s why there is an AVG(x) function in the SELECT clause, but not in the WHERE clause
<br><br></li>
<li>But some operations only make sense in the context of a full relation</li>
<li>We&#39;ll discuss those operations next</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-61" style="background:;">
  <hgroup>
    <h2>Duplicate Elimination</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Recall that databases are working on bags instead of sets</li>
<li>But many times we really want the answers to be sets
<br><br></li>
<li>That&#39;s where <strong>duplicate elimination</strong> comes in</li>
<li>This is easily done, with <code>SELECT DISTINCT</code> instead of <code>SELECT</code></li>
</ul>

<pre><code>SELECT DISTINCT starName
  FROM StarsIn, Movies
 WHERE StarsIn.title = Movies.title
   AND StarsIn.year = Movies.year
   AND Movies.length &gt; 120
</code></pre>

<ul>
<li>How would this be different without the <code>DISTINCT</code> keyword?</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-62" style="background:;">
  <hgroup>
    <h2>Duplicate Elimination with Set Operations</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose you take the <code>UNION</code> or <code>INTERSECT</code> or <code>EXCEPT</code> of two relations</li>
<li>By default, this <strong>eliminates duplicates</strong>

<ul>
<li>This sort of makes sense</li>
<li>The implementation of <code>INTERSECT</code> and <code>EXCEPT</code> is most efficient when eliminating duplicates</li>
<li><code>UNION</code> would be more efficient with duplicates, but it follows the pattern of the other set operations
<br><br></li>
</ul></li>
<li>Here, you can ask explicitly for bag behavior (i.e., to have the duplicates left)</li>
<li>Simply use <code>UNION ALL</code> or <code>INTERSECT ALL</code> or <code>EXCEPT ALL</code></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-63" style="background:;">
  <hgroup>
    <h2>Grouping and Aggregation in SQL</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We&#39;ve already seen the grouping operator \(\gamma\) in relational algebra</li>
<li>The equivalent operation is <code>GROUP BY</code> in SQL</li>
</ul>

<pre><code>  SELECT major, AVG(salary)
    FROM Students
GROUP BY major
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-64" style="background:;">
  <hgroup>
    <h2>Flashback: Grouping and Aggregation</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>In general, we have \(\gamma_{L}(R)\)</li>
<li>The list \(L\) may contain

<ul>
<li><strong>grouping attributes</strong> from \(R\), e.g., \(A\)</li>
<li><strong>aggregated attributes</strong> from \(R\), e.g., \(\text{SUM}(B)\)
<br><br></li>
</ul></li>
<li>To execute \(\gamma_{L}(R)\):

<ol>
<li>Partition the tuples of \(R\) into groups according to the values in the grouping attributes</li>
<li>For each group, create a tuple that has the values of the grouping attributes and the
aggregated values of the aggregated attributes</li>
</ol></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-65" style="background:;">
  <hgroup>
    <h2>Grouping and Aggregation in SQL</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>  SELECT major, AVG(salary)
    FROM Students
GROUP BY major
</code></pre>

<table><thead>
<tr>
<th>Major</th>
<th>\(\text{AVG}(\text{Salary})\)</th>
</tr>
</thead><tbody>
<tr>
<td>ARTH</td>
<td>12,000</td>
</tr>
<tr>
<td>COSC</td>
<td>62,500</td>
</tr>
<tr>
<td>EECS</td>
<td>56,500</td>
</tr>
</tbody></table>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-66" style="background:;">
  <hgroup>
    <h2>Grouping and Aggregation in SQL</h2>
  </hgroup>
  <article data-timings="">
    <pre><code>  SELECT major, COUNT(EnrolledIn.crn), AVG(salary)
    FROM Students, EnrolledIn, Courses
   WHERE Students.id = EnrolledIn.id
     AND Courses.crn = EnrolledIn.crn
     AND Courses.dept = &#39;MATH&#39;
GROUP BY major
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-67" style="background:;">
  <hgroup>
    <h2>Aggregation Operators</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>SQL supports five standard aggregation operators

<ul>
<li>SUM, AVG, MIN, MAX, COUNT</li>
</ul></li>
<li>Each aggregation operator takes a single attribute as an argument, e.g., <code>AVG(salary)</code></li>
<li>In addition, the <code>COUNT</code> operator has a special syntax <code>COUNT(*)</code> that counts all the tuples in the result</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-68" style="background:;">
  <hgroup>
    <h2>Aggregation Operators and Duplicates</h2>
  </hgroup>
  <article data-timings="">
    <table><thead>
<tr>
<th>StudentId</th>
<th>Major</th>
<th>Salary</th>
</tr>
</thead><tbody>
<tr>
<td>1001</td>
<td>COSC</td>
<td>60,000</td>
</tr>
<tr>
<td>2010</td>
<td>ARTH</td>
<td>12,000</td>
</tr>
<tr>
<td>1022</td>
<td>COSC</td>
<td>65,000</td>
</tr>
<tr>
<td>3095</td>
<td>EECS</td>
<td>58,000</td>
</tr>
<tr>
<td>9403</td>
<td>EECS</td>
<td>55,000</td>
</tr>
</tbody></table>

<p><br></p>

<table><thead>
<tr>
<th>Aggregation</th>
<th>Value</th>
</tr>
</thead><tbody>
<tr>
<td>COUNT(*)</td>
<td>5</td>
</tr>
<tr>
<td>COUNT(Major)</td>
<td>5</td>
</tr>
<tr>
<td>COUNT(DISTINCT Major)</td>
<td>3</td>
</tr>
</tbody></table>

<ul>
<li>The <code>DISTINCT</code> keyword inside an aggregation limits the rows under consideration</li>
<li>This is only useful for <code>COUNT(DISTINCT x)</code></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-69" style="background:;">
  <hgroup>
    <h2>Aggregation Operators and NULLs</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>NULLs complicate the semantics of aggregation operators a little</li>
<li>The basic rule is <strong>NULLs are completely ignored</strong></li>
</ul>

<table><thead>
<tr>
<th>Aggregation</th>
<th>Value</th>
</tr>
</thead><tbody>
<tr>
<td>COUNT(*)</td>
<td># of rows</td>
</tr>
<tr>
<td>COUNT(Major)</td>
<td># of rows with a non-NULL Major</td>
</tr>
<tr>
<td>SUM(Salary)</td>
<td>sum of the non-NULL Salary values</td>
</tr>
</tbody></table>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-70" style="background:;">
  <hgroup>
    <h2>Grouping and NULLs</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose we <code>GROUP BY</code> Major</li>
<li>We&#39;ll have a group for each different Major
<br><br></li>
<li>What about the entries with NULL Majors?</li>
<li>Remember that NULL is not the same as another NULL value</li>
<li>I.e., if two students have a NULL major, that does not mean they are studying the same (unknown? undeclared?) major
<br><br></li>
<li>But it would be very strange to have an entry for each row with a NULL major</li>
<li>The SQL standard treats NULLs as <strong>the same value</strong> for the purpose of grouping</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-71" style="background:;">
  <hgroup>
    <h2>Grouping and NULLs</h2>
  </hgroup>
  <article data-timings="">
    
<div style='float:left;width:48%;'>
  <table><thead>
<tr>
<th>StudentId</th>
<th>Major</th>
<th>Salary</th>
</tr>
</thead><tbody>
<tr>
<td>1001</td>
<td>COSC</td>
<td>60,000</td>
</tr>
<tr>
<td>2010</td>
<td>ARTH</td>
<td>12,000</td>
</tr>
<tr>
<td>1022</td>
<td>NULL</td>
<td>65,000</td>
</tr>
<tr>
<td>3095</td>
<td>EECS</td>
<td>58,000</td>
</tr>
<tr>
<td>9403</td>
<td>NULL</td>
<td>55,000</td>
</tr>
</tbody></table>

</div>
<div style='float:right;width:48%;'>
  <pre><code>  SELECT major, AVG(salary)
    FROM Students
GROUP BY major
</code></pre>

<table><thead>
<tr>
<th>Major</th>
<th>\(\text{AVG}(\text{Salary})\)</th>
</tr>
</thead><tbody>
<tr>
<td>ARTH</td>
<td>12,000</td>
</tr>
<tr>
<td>COSC</td>
<td>60,000</td>
</tr>
<tr>
<td>EECS</td>
<td>58,000</td>
</tr>
<tr>
<td>NULL</td>
<td>60,000</td>
</tr>
</tbody></table>

</div>
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-72" style="background:;">
  <hgroup>
    <h2>Grouping and NULLs</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>One more thing: What if a group is empty?</li>
<li>This could happen, for example, if all the entries in it are NULL
<br><br></li>
<li>Then the answer is NULL for SUM, AVG, MIN, MAX</li>
<li>But the answer is 0 for COUNT
<br><br></li>
<li>This is actually consistent with our definitions from before, but it surprises some people</li>
</ul>

<table><thead>
<tr>
<th>Aggregation</th>
<th>Value</th>
</tr>
</thead><tbody>
<tr>
<td>COUNT(*)</td>
<td># of rows</td>
</tr>
<tr>
<td>COUNT(Major)</td>
<td># of rows with a non-NULL Major</td>
</tr>
<tr>
<td>SUM(Salary)</td>
<td>sum of the non-NULL Salary values</td>
</tr>
</tbody></table>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-73" style="background:;">
  <hgroup>
    <h1>Database Modifications</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-74" style="background:;">
  <hgroup>
    <h2>Database Modifications</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>So far, we&#39;ve been using SQL as a query language</li>
<li>But SQL is also a <strong>data manipulation language</strong>, so we can modify the database with it
<br><br></li>
<li>Modifications can be

<ul>
<li><strong>Insert</strong> a tuple into a relation</li>
<li><strong>Delete</strong> tuples from a relation</li>
<li><strong>Update</strong> values of some tuples in a relation
<br><br></li>
</ul></li>
<li>Together with simple queries, these are known as CRUD operations

<ul>
<li><strong>C</strong>reate, <strong>R</strong>ead, <strong>U</strong>pdate, <strong>D</strong>elete</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-75" style="background:;">
  <hgroup>
    <h2>Insert Operations</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The easiest operation adds a tuple to a relation

<ul>
<li><code>INSERT INTO R(A1,A2,...,An) VALUES (v1,v2,...,vn)</code></li>
</ul></li>
<li>Some databases allow you to insert more than one tuple, by providing a comma-separated list of tuples after <code>VALUES</code>
<br><br></li>
<li>Note, the list of attributes <code>(A1,A2,...,An)</code> is optional</li>
<li>But always use it

<ul>
<li>The order of the attributes may change</li>
<li>The number of attributes may change
<br><br></li>
</ul></li>
<li>But wait, what if there is an attribute B1 that is not listed?</li>
<li>The new tuple gets a value of B1 that is either

<ul>
<li>the default value specified for B1 in the schema</li>
<li>NULL</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-76" style="background:;">
  <hgroup>
    <h2>Inserting an Entire Table</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>You can insert many tuples at once with <code>INSERT ... SELECT</code></li>
<li>The syntax is basically an <code>INSERT INTO ...</code> clause followed by a <code>SELECT</code> query (instead of <code>VALUES</code>)</li>
</ul>

<pre><code>INSERT INTO LongMovies(title, year, length, genre)
SELECT title, year, length, genre
  FROM Movies
 WHERE length &gt; 120 
</code></pre>

<ul>
<li>I make use of <code>INSERT ... SELECT</code> a lot when I&#39;m modifying tables</li>
<li>You may find it useful in your project</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-77" style="background:;">
  <hgroup>
    <h2>Correlated Updates</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Consider this query</li>
</ul>

<pre><code>INSERT INTO Studios(name)
SELECT DISTINCT studioName
  FROM Movies
 WHERE studioName NOT IN (SELECT name FROM Studios)
</code></pre>

<ul>
<li>A few things to note:

<ol>
<li><code>DISTINCT</code> is important to avoid creating duplicate rows</li>
<li>The subquery keeps us from adding a studio that was already known</li>
<li>The semantics of SQL require that the <code>SELECT</code> query completely execute before any tuples are added</li>
</ol></li>
</ul>

<ul class = "build incremental">
<li>Reality strikes again: This is a <strong>correlated subquery</strong></li>
<li>Many databases do not support <strong>correlated update subqueries</strong></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-78" style="background:;">
  <hgroup>
    <h2>Deleting Tuples</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The syntax is

<ul>
<li><code>DELETE FROM R WHERE ...</code>
<br><br></li>
</ul></li>
<li>Hint: Always run a <code>SELECT FROM R WHERE ...</code> before doing the deletion!
<br><br></li>
</ul>

<pre><code>DELETE FROM Movies
      WHERE genre &lt;&gt; &#39;scifi&#39;
</code></pre>

<ul>
<li>Note that the WHERE clause may match 0, 1, or many tuples</li>
<li>All matching tuples (if any) will be deleted</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-79" style="background:;">
  <hgroup>
    <h2>Updating Tuples</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Finally, the UPDATE command allows us to change the values in one or more tuples

<ul>
<li><code>UPDATE R SET A1=v1, A2=v2, ..., An=vn WHERE ...</code></li>
</ul></li>
</ul>

<pre><code>UPDATE Movie
   SET thumbsUp = 2
 WHERE (title, year) IN (SELECT movieTitle, movieYear
                           FROM StarsIn 
                          WHERE starName = &#39;Harrison Ford&#39;)
</code></pre>

<ul>
<li>Note: This is <strong>not</strong> a correlated subquery!</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-80" style="background:;">
  <hgroup>
    <h1>Transactions in SQL</h1>
  </hgroup>
  <article data-timings="">
    
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-81" style="background:;">
  <hgroup>
    <h2>Transactions in SQL</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>We&#39;ve been looking at SQL queries as if <strong>each query executed completely on its own</strong></li>
<li>In particular, we&#39;ve ignored

<ul>
<li>what happens when more than one query is being executed at a time?</li>
<li>what happens when a query fails to execute?</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-82" style="background:;">
  <hgroup>
    <h2>Transactions: Scenario 1</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Here is a classic scenario showing the need to perform transactions</li>
</ul>

<pre><code>UPDATE Accounts
   SET Balance = Balance + 200
 WHERE AccountId = 10000;

UPDATE Accounts
   SET Balance = Balance - 200
 WHERE AccountId = 10001;
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-83" style="background:;">
  <hgroup>
    <h2>Transactions: Scenario 2</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Here is another subtle interaction, this time between rows of the same table</li>
</ul>

<pre><code>UPDATE Employees
   SET Salary = 1.03 * Salary
</code></pre>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-84" style="background:;">
  <hgroup>
    <h2>Transactions: Scenario 3 (Long-lived Transactions)</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Here is an example of a long-lived transaction
<br><br>

<ol>
<li>User asks to purchase tickets for an upcoming concert</li>
<li>System offers the user a selection of possible seats</li>
<li>User selects the seats and offers payment</li>
<li>System processes payment</li>
<li>System assigns seats to user</li>
</ol></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-85" style="background:;">
  <hgroup>
    <h2>Transactions</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>In general, we want <strong>database transactions</strong> to have these properties
<br><br>

<ol>
<li><strong>Atomicity</strong> meaning the entire transaction is processed fully or not at all</li>
<li><strong>Serializability</strong> meaning two transactions \(T_1\) and \(T_2\) act <strong>as if</strong> they
were executed sequentially (either \(T_1; T_2\) or \(T_2; T_1\))
<br><br></li>
</ol></li>
<li>We normally talk about the ACID properties to refer to the same idea

<ul>
<li>Atomicity</li>
<li>Consistency</li>
<li>Isolation</li>
<li>Durability</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-86" style="background:;">
  <hgroup>
    <h2>Implementing Transactions</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>There are two elements to implementing transactions
<br><br></li>
<li>First, we must ensure atomicity

<ul>
<li>This can be done by writing entries to logs</li>
<li>Instead of simply replacing X with 2, we write to a log that we&#39;ll be replacing X with 2, and then we replace X with 2</li>
<li>Once we write to the log, we are <strong>committed</strong> to finishing the operation</li>
<li>Or, we can commit to <strong>undo</strong> all the operations in the same transaction
<br><br></li>
</ul></li>
<li>Second, we must ensure isolation

<ul>
<li>This is usually handled by locking</li>
<li>Variants (e.g., optimistic locking) are also possible</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-87" style="background:;">
  <hgroup>
    <h2>Long-lived Transactions</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>In general, 100s of transactions may be running concurrently</li>
<li>It&#39;s unfeasible to run only one transaction at a time</li>
<li>So we need a mechanism that allows us to run multiple transactions while avoiding interactions</li>
<li>Typically this is done via locking
<br><br></li>
<li>Long-lived transactions make this very difficult</li>
<li>A single long-lived transaction could lock out all the other transactions, and overall throughput drops to zero
<br><br></li>
<li>Good database applications avoid long-lived transactions</li>
<li>E.g., they can go back to the user with

<ul>
<li>I&#39;m sorry, but that seat is no longer available</li>
<li>Or they can allow a seat to be available, unavailable, and <strong>reserved</strong> (for a period of time)</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-88" style="background:;">
  <hgroup>
    <h2>Specifying Transactions</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>A transaction is one or more database operations that must be executed atomically and (apparently) serially</li>
<li>Transactions can be bracketed around

<ul>
<li><code>START TRANSACTION</code></li>
<li>Either <code>COMMIT</code> or <code>ROLLBACK</code>
<br><br></li>
</ul></li>
<li><p>Programmatic interfaces will offer their own variants</p>

<pre><code>tx = session.beginTransaction();
...
tx.commit ();  
</code></pre></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-89" style="background:;">
  <hgroup>
    <h2>Performance of Transactions</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Implementing transactions involves tremendous overhead</li>
<li>This slide shows Stonebraker&#39;s depiction of database performance bottlenecks for typical OLTP applications</li>
</ul>

<div class="centered">
    <img width="75%" src="assets/img/01-oltp-pie.png" title="OLTP Overhead Pie" alt="OLTP Overhead Pie">
</div>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-90" style="background:;">
  <hgroup>
    <h2>Enhancing Performance of Transactions</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>For the future: Migrate to new technologies better suited to your needs
<br><br></li>
</ul>

<div style='float:left;width:48%;'>
  <div class="centered">
    <img src="assets/img/dbms-use-cases.png" title="DBMS Use Case Performance Needs" alt="DBMS Use Case Performance Needs">
</div>

</div>
<div style='float:right;width:48%;'>
  <div class="centered">
    <img src="assets/img/dbms-use-cases-served.png" title="DBMS Use Case Solutions" alt="DBMS Use Case Solutions">
</div>

</div>
  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-91" style="background:;">
  <hgroup>
    <h2>Enhancing Performance of Transactions</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>In the meantime, we try to squeeze as much performance as we can out of the &quot;elephants&quot; (as Stonebraker calls them)
<br><br></li>
<li>Trick #1: If possible, let the database know that the current session is <strong>read only</strong></li>
<li>You can do this with the command <code>SET TRANSACTION READ ONLY</code></li>
<li>Since read only transactions do not interfere with each other, the database may be able to execute a bunch of them faster
<br><br></li>
<li>Trick #2: If possible, let the database know we&#39;re willing to live with less isolation than it would normally guarantee</li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-92" style="background:;">
  <hgroup>
    <h2>Dirty Reads</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>A common problem of lowered isolation is <strong>dirty reads</strong></li>
<li>Consider this sequence of steps:

<ol>
<li>T1 writes new value to X</li>
<li>T2 reads the value of X</li>
<li>T1 aborts</li>
</ol></li>
<li>In this sequence, T2 reads a value of X that <strong>never existed</strong></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-93" style="background:;">
  <hgroup>
    <h2>Do Dirty Reads Matter?</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>In some cases, absolutely!

<ul>
<li>Check to see if there is enough money in account</li>
<li>Perform a withdrawal
<br><br></li>
</ul></li>
<li>In other cases, not so much

<ul>
<li>Find one of the best seats available and mark it reserved</li>
<li>Offer the seat to a customer</li>
<li>If customer buys it, mark seat as occupied</li>
<li>Otherwise, mark the seat as available again
<br><br></li>
</ul></li>
<li>Or very little

<ul>
<li>T1: enter final grades for students in this class</li>
<li>T2: compute average GPA for all students in UW</li>
</ul></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-94" style="background:;">
  <hgroup>
    <h2>Accepting Dirty Reads</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Suppose that for <strong>your application</strong> dirty reads are OK</li>
<li><p>This may result in significantly better performance for your application <strong>if the database knows dirty reads are OK</strong></p>

<pre><code>SET TRANSACTION READ WRITE
  ISOLATION LEVEL READ UNCOMMITTED
</code></pre></li>
<li><p>The <code>READ UNCOMMITTED</code> tells the database we&#39;re OK with reading data written but not yet committed by another transaction</p></li>
<li><p>I.e., we&#39;re OK with (potentially) dirty reads
<br><br></p></li>
<li><p>Note: It may be safer to allow dirty reads for <strong>read only</strong> transactions</p></li>
<li><p>If your transactions is read/write, then it may propagate bad information</p></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-95" style="background:;">
  <hgroup>
    <h2>Other Isolation Levels</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>Dirty reads are not the only potential problems</li>
<li>SQL allows other isolation levels
<br><br></li>
<li>A little more secure (and more costly) than <code>READ UNCOMMITTED</code> is <code>READ COMMITTED</code></li>
<li>This means that the transaction may read data from other transactions after they commit</li>
<li>This is <strong>not</strong> the same as serializable!

<ol>
<li>T2 sets X to 10</li>
<li>T1 reads X (and gets the initial value of X, say 0)</li>
<li>T2 commits</li>
<li>T1 reads X again (and this time it gets 10)</li>
</ol></li>
<li>So <code>READ COMMITTED</code> avoids dirty reads, but it allows <strong>non-repeatable reads</strong></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-96" style="background:;">
  <hgroup>
    <h2>Other Isolation Levels</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>SQL allows you to make transactions a little more secure (and more costly) with <code>REPEATABLE READ</code>
<br><br></li>
<li>This is <strong>not</strong> the same as serializable!

<ol>
<li>T1 gets the maximum value of X (and gets 100)</li>
<li>T2 gets the maximum value of X (and also gets 100)</li>
<li>T2 adds a new row with X set to max+1 (i.e., 101)</li>
<li>T1 also adds a new row with X set to max+1 (i.e., 101)</li>
</ol></li>
<li>The problem, of course, is that T1 does not see the change that T2 made</li>
<li>So 101 is no longer the value of max(X)+1</li>
<li>This is called a <strong>phantom read</strong></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-97" style="background:;">
  <hgroup>
    <h2>Other Isolation Levels</h2>
  </hgroup>
  <article data-timings="">
    <ul>
<li>The most restrictive isolation level is <code>SERIALIZABLE</code></li>
<li>This should be the default (but it&#39;s usually not)</li>
<li>Oracle, PostgreSQL, and Microsoft SQL Server all default to <code>READ COMMITTED</code> </li>
<li>MySQL defaults to <code>REPEATABLE READ</code>
<br><br></li>
<li><p>You can always be explicit, e.g.,</p>

<pre><code>SET TRANSACTION READ WRITE
  ISOLATION LEVEL REPEATABLE READ
</code></pre></li>
</ul>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-98" style="background:;">
  <hgroup>
    <h2>Isolation Levels</h2>
  </hgroup>
  <article data-timings="">
    <table><thead>
<tr>
<th>Isolation Level</th>
<th>Characteristics</th>
</tr>
</thead><tbody>
<tr>
<td>READ UNCOMMITTED</td>
<td>Dirty reads. No locking! Anything goes!</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>Can only read committed rows (but may read different versions of a row)</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>Multiple reads always retrieve same version of rows, but may have phantom reads</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>Pure isolation, real transactions</td>
</tr>
</tbody></table>

  </article>
  <!-- Presenter Notes -->
</slide>

<slide class="" id="slide-99" style="background:;">
  <hgroup>
    <h2>Isolation Levels</h2>
  </hgroup>
  <article data-timings="">
    <table><thead>
<tr>
<th>Isolation Level</th>
<th>Dirty Reads</th>
<th>Non-repeatable Reads</th>
<th>Phantom Reads</th>
</tr>
</thead><tbody>
<tr>
<td>READ UNCOMMITTED</td>
<td>Allowed</td>
<td>Allowed</td>
<td>Allowed</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>Not allowed</td>
<td>Allowed</td>
<td>Allowed</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>Not allowed</td>
<td>Not allowed</td>
<td>Allowed</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>Not allowed</td>
<td>Not allowed</td>
<td>Not allowed</td>
</tr>
</tbody></table>

  </article>
  <!-- Presenter Notes -->
</slide>

    <slide class="backdrop"></slide>
  </slides>
  <div class="pagination pagination-small" id='io2012-ptoc' style="display:none;">
    <ul>
      <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=1 title='NA'>
         1
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=2 title='Simple Queries in SQL'>
         2
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=3 title='Using SQL'>
         3
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=4 title='Simple Queries in SQL'>
         4
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=5 title='Simple Queries in SQL'>
         5
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=6 title='Reading SQL Queries'>
         6
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=7 title='SQL Queries and Relational Algebra'>
         7
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=8 title='Projection in SQL'>
         8
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=9 title='Extended Projection in SQL'>
         9
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=10 title='Selection in SQL'>
         10
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=11 title='Conditions in SQL'>
         11
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=12 title='Conditions in SQL'>
         12
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=13 title='String Comparisons in SQL'>
         13
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=14 title='Locales in SQL'>
         14
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=15 title='String Operators'>
         15
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=16 title='String Comparisons'>
         16
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=17 title='String LIKE Comparisons'>
         17
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=18 title='String LIKE Comparisons'>
         18
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=19 title='Date and Time Comparisons'>
         19
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=20 title='ANSI Date and Time Constants'>
         20
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=21 title='ANSI Date and Time Constants'>
         21
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=22 title='ANSI Date and Time Conditions'>
         22
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=23 title='NULL Values'>
         23
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=24 title='NULL Values in Expressions'>
         24
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=25 title='NULL Values in Conditions'>
         25
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=26 title='Three-valued Conditions'>
         26
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=27 title='NULL Values in Conditions'>
         27
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=28 title='Ordering the Output'>
         28
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=29 title='Queries Involving More Than One Relation'>
         29
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=30 title='Queries Involving More Than One Relation'>
         30
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=31 title='Disambiguating Attributes'>
         31
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=32 title='Disambiguating Attributes'>
         32
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=33 title='Sidebar: Hint on Multiple Copies'>
         33
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=34 title='SQL Queries and Relational Algebra'>
         34
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=35 title='Set Operations in SQL'>
         35
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=36 title='Set Operations in SQL'>
         36
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=37 title='Subqueries'>
         37
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=38 title='Subqueries'>
         38
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=39 title='Subqueries that Produce Single Values'>
         39
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=40 title='Subqueries that Produce Single Values'>
         40
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=41 title='How Subqueries Are Executed'>
         41
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=42 title='The Problem with Subqueries'>
         42
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=43 title='Conditions Involving Relations'>
         43
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=44 title='Is the Result Empty?'>
         44
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=45 title='Does the Result Contain a Specific Value?'>
         45
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=46 title='Does the Result Contain a Specific Value?'>
         46
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=47 title='Are All the Entries Bigger than Some Value?'>
         47
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=48 title='Are Some Entries Bigger than Some Value?'>
         48
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=49 title='Correlated Subqueries'>
         49
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=50 title='Subqueries in FROM Clauses'>
         50
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=51 title='Subqueries in FROM Clauses'>
         51
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=52 title='SQL Join'>
         52
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=53 title='SQL Join'>
         53
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=54 title='SQL Theta Joins'>
         54
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=55 title='Natural Joins'>
         55
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=56 title='Outer Joins'>
         56
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=57 title='Left and Right Outer Joins'>
         57
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=58 title='Reality and Outer Joins'>
         58
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=59 title='Full-Relation Operations'>
         59
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=60 title='Full-Relation Operations'>
         60
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=61 title='Duplicate Elimination'>
         61
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=62 title='Duplicate Elimination with Set Operations'>
         62
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=63 title='Grouping and Aggregation in SQL'>
         63
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=64 title='Flashback: Grouping and Aggregation'>
         64
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=65 title='Grouping and Aggregation in SQL'>
         65
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=66 title='Grouping and Aggregation in SQL'>
         66
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=67 title='Aggregation Operators'>
         67
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=68 title='Aggregation Operators and Duplicates'>
         68
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=69 title='Aggregation Operators and NULLs'>
         69
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=70 title='Grouping and NULLs'>
         70
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=71 title='Grouping and NULLs'>
         71
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=72 title='Grouping and NULLs'>
         72
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=73 title='Database Modifications'>
         73
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=74 title='Database Modifications'>
         74
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=75 title='Insert Operations'>
         75
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=76 title='Inserting an Entire Table'>
         76
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=77 title='Correlated Updates'>
         77
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=78 title='Deleting Tuples'>
         78
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=79 title='Updating Tuples'>
         79
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=80 title='Transactions in SQL'>
         80
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=81 title='Transactions in SQL'>
         81
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=82 title='Transactions: Scenario 1'>
         82
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=83 title='Transactions: Scenario 2'>
         83
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=84 title='Transactions: Scenario 3 (Long-lived Transactions)'>
         84
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=85 title='Transactions'>
         85
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=86 title='Implementing Transactions'>
         86
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=87 title='Long-lived Transactions'>
         87
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=88 title='Specifying Transactions'>
         88
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=89 title='Performance of Transactions'>
         89
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=90 title='Enhancing Performance of Transactions'>
         90
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=91 title='Enhancing Performance of Transactions'>
         91
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=92 title='Dirty Reads'>
         92
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=93 title='Do Dirty Reads Matter?'>
         93
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=94 title='Accepting Dirty Reads'>
         94
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=95 title='Other Isolation Levels'>
         95
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=96 title='Other Isolation Levels'>
         96
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=97 title='Other Isolation Levels'>
         97
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=98 title='Isolation Levels'>
         98
      </a>
    </li>
    <li>
      <a href="#" target="_self" rel='tooltip' 
        data-slide=99 title='Isolation Levels'>
         99
      </a>
    </li>
  </ul>
  </div>  <!--[if IE]>
    <script 
      src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js">  
    </script>
    <script>CFInstall.check({mode: 'overlay'});</script>
  <![endif]-->
</body>
  <!-- Load Javascripts for Widgets -->
  <script src="libraries/widgets/bootstrap/js/bootstrap.min.js"></script>
<script src="libraries/widgets/bootstrap/js/bootbox.min.js"></script>

  <!-- MathJax: Fall back to local if CDN offline but local image fonts are not supported (saves >100MB) -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true
      }
    });
  </script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- <script src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script> -->
  <script>window.MathJax || document.write('<script type="text/x-mathjax-config">MathJax.Hub.Config({"HTML-CSS":{imageFont:null}});<\/script><script src="libraries/widgets/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"><\/script>')
</script>
<script>  
  $(function (){ 
    $("#example").popover(); 
    $("[rel='tooltip']").tooltip(); 
  });  
  </script>  
  <!-- LOAD HIGHLIGHTER JS FILES -->
  <script src="libraries/highlighters/highlight.js/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <!-- DONE LOADING HIGHLIGHTER JS FILES -->
   
  </html>